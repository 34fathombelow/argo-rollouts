{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Argo Rollouts - Advanced Kubernetes Deployment Controller What is Argo Rollouts? Argo Rollouts introduces a new custom resource called a Rollout to provide additional deployment strategies such as Blue Green and Canary to Kubernetes. The Rollout custom resource provides feature parity with the deployment resource with additional deployment strategies. Check out the Deployment Concepts for more information on the various deployment strategies. Why Argo Rollouts? Deployments resources offer two strategies to deploy changes: RollingUpdate and Recreate . While these strategies can solve a wide number of use cases, large scale production deployments use additional strategies, such as blue-green or canary, that are missing from the Deployment controller. In order to use these strategies in Kubernetes, users are forced to build scripts on top of their deployments. The Argo Rollouts controller provides these strategies as simple declarative, configurable, GitOps-friendly options. Getting Started Quick Start Argo Rollouts can be installed by running the following commands: $ kubectl create namespace argo-rollouts $ kubectl apply -n argo-rollouts -f https://raw.githubusercontent.com/argoproj/argo-rollouts/stable/manifests/install.yaml Check out the getting started guide to walk through creating and then updating a rollout object. How does it work? Similar to the deployment object, the Argo Rollouts controller will manage the creation, scaling, and deletion of ReplicaSets. These ReplicaSets are defined by the spec.template field, which uses the same pod template as the deployment object. When the spec.template is changed, that signals to the Argo Rollouts controller that a new ReplicaSet will be introduced. The controller will use the strategy set within the spec.strategy field in order to determine how the rollout will progress from the old ReplicaSet to the new ReplicaSet. Once that new ReplicaSet has successfully progressed into the stable version, that Rollout will be marked as the stable ReplicaSet. If another change occurs in the spec.template during a transition from a stable ReplicaSet to a new ReplicaSet. The previously new ReplicaSet will be scaled down, and the controller will try to progress the ReplicasSet that reflects the spec.template field. There is more information on the behaviors of each strategy in the spec section. Use cases of Argo Rollouts A user wants to run last minute functional tests on the new version before it starts to serve production traffic. With the BlueGreen strategy, Argo Rollouts allow users to specify a preview service and an active service. The Rollout will configure the preview service to send traffic to the new version while the active service continues to receive production traffic. Once a user is satisfied, they can promote the preview service to be the new active service. ( example ) Before a new version starts receiving live traffic, a generic set of steps need to be executed beforehand. With the BlueGreen Strategy, the user can bring up the new version without it receiving traffic from the active service. Once those steps finish executing, the rollout can cut over traffic to the new version. A user wants to give a small percentage of the production traffic to a new version of their application for a couple of hours. Afterward, they want to scale down the new version and look at some metrics to determine if the new version is performant compared to the old version. Then they will decide if they want to rollout the new version for all of the production traffic or stick with the current version. With the canary strategy, the rollout can scale up a replica with the new version to receive a specified percentage of traffic, wait for a specified amount of time, set the percentage back to 0, and then wait to rollout out to service all of the traffic once the user is satisfied. ( example ) A user wants to slowly give the new version more production traffic. They start by giving it a small percentage of the live traffic and wait a while before giving the new version more traffic. Eventually, the new version will receive all the production traffic. With the canary strategy, the user specifies the percentages they want the new version to receive and the amount of time to wait between percentages. ( example A user wants to use the normal Rolling Update strategy from the deployment. If a user uses the canary strategy with no steps, the rollout will use the max surge and max unavailable values to roll to the new version. ( example )","title":"Overview"},{"location":"#argo-rollouts-advanced-kubernetes-deployment-controller","text":"","title":"Argo Rollouts - Advanced Kubernetes Deployment Controller"},{"location":"#what-is-argo-rollouts","text":"Argo Rollouts introduces a new custom resource called a Rollout to provide additional deployment strategies such as Blue Green and Canary to Kubernetes. The Rollout custom resource provides feature parity with the deployment resource with additional deployment strategies. Check out the Deployment Concepts for more information on the various deployment strategies.","title":"What is Argo Rollouts?"},{"location":"#why-argo-rollouts","text":"Deployments resources offer two strategies to deploy changes: RollingUpdate and Recreate . While these strategies can solve a wide number of use cases, large scale production deployments use additional strategies, such as blue-green or canary, that are missing from the Deployment controller. In order to use these strategies in Kubernetes, users are forced to build scripts on top of their deployments. The Argo Rollouts controller provides these strategies as simple declarative, configurable, GitOps-friendly options.","title":"Why Argo Rollouts?"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#quick-start","text":"Argo Rollouts can be installed by running the following commands: $ kubectl create namespace argo-rollouts $ kubectl apply -n argo-rollouts -f https://raw.githubusercontent.com/argoproj/argo-rollouts/stable/manifests/install.yaml Check out the getting started guide to walk through creating and then updating a rollout object.","title":"Quick Start"},{"location":"#how-does-it-work","text":"Similar to the deployment object, the Argo Rollouts controller will manage the creation, scaling, and deletion of ReplicaSets. These ReplicaSets are defined by the spec.template field, which uses the same pod template as the deployment object. When the spec.template is changed, that signals to the Argo Rollouts controller that a new ReplicaSet will be introduced. The controller will use the strategy set within the spec.strategy field in order to determine how the rollout will progress from the old ReplicaSet to the new ReplicaSet. Once that new ReplicaSet has successfully progressed into the stable version, that Rollout will be marked as the stable ReplicaSet. If another change occurs in the spec.template during a transition from a stable ReplicaSet to a new ReplicaSet. The previously new ReplicaSet will be scaled down, and the controller will try to progress the ReplicasSet that reflects the spec.template field. There is more information on the behaviors of each strategy in the spec section.","title":"How does it work?"},{"location":"#use-cases-of-argo-rollouts","text":"A user wants to run last minute functional tests on the new version before it starts to serve production traffic. With the BlueGreen strategy, Argo Rollouts allow users to specify a preview service and an active service. The Rollout will configure the preview service to send traffic to the new version while the active service continues to receive production traffic. Once a user is satisfied, they can promote the preview service to be the new active service. ( example ) Before a new version starts receiving live traffic, a generic set of steps need to be executed beforehand. With the BlueGreen Strategy, the user can bring up the new version without it receiving traffic from the active service. Once those steps finish executing, the rollout can cut over traffic to the new version. A user wants to give a small percentage of the production traffic to a new version of their application for a couple of hours. Afterward, they want to scale down the new version and look at some metrics to determine if the new version is performant compared to the old version. Then they will decide if they want to rollout the new version for all of the production traffic or stick with the current version. With the canary strategy, the rollout can scale up a replica with the new version to receive a specified percentage of traffic, wait for a specified amount of time, set the percentage back to 0, and then wait to rollout out to service all of the traffic once the user is satisfied. ( example ) A user wants to slowly give the new version more production traffic. They start by giving it a small percentage of the live traffic and wait a while before giving the new version more traffic. Eventually, the new version will receive all the production traffic. With the canary strategy, the user specifies the percentages they want the new version to receive and the amount of time to wait between percentages. ( example A user wants to use the normal Rolling Update strategy from the deployment. If a user uses the canary strategy with no steps, the rollout will use the max surge and max unavailable values to roll to the new version. ( example )","title":"Use cases of Argo Rollouts"},{"location":"CONTRIBUTING/","text":"Contributing Before You Start Argo Rollouts is written in Golang. If you do not have a good grounding in Go, try out the tutorial . Pre-requisites Install: docker golang kubectl kustomize minikube or Docker for Desktop Argo Rollout additionally uses * golangci-lint to lint the project. Run the following commands to install them: go get -u github.com/golangci/golangci-lint/cmd/golangci-lint Brew users can quickly install the lot: brew install go kubectl kustomize Set up environment variables (e.g. is ~/.bashrc ): export GOPATH = ~/go export PATH = $PATH : $GOPATH /bin Checkout the code: go get -u github.com/argoproj/argo-rollouts cd ~/go/src/github.com/argoproj/argo-rollouts Run the following command to download all the dependencies: go mod download Building go.mod is used, so the go build/test commands automatically install the needed dependencies The make controller command will build the controller. make codegen - Runs the code generator that creates the informers, client, lister, and deepcopies from the types.go and modifies the open-api spec. This command fails if the user has not run go mod download to download all the dependencies of the project. Running Tests To run unit tests: make test Running Locally It is much easier to run and debug if you run Argo Rollout in your local machine than in the Kubernetes cluster. cd ~/go/src/github.com/argoproj/argo-rollouts make controller ./dist/rollouts-controller Running Local Containers You may need to run containers locally, so here's how: Create login to Docker Hub, then login. docker login Add your username as the environment variable, e.g. to your ~/.bash_profile : export IMAGE_NAMESPACE = argoproj Build the images: DOCKER_PUSH = true make image Update the manifests: make manifests Install the manifests: kubectl -n argo-rollouts apply -f manifests/install.yaml Upgrading Kubernetes Libraries Argo Rollouts has a dependency on the kubernetes/kubernetes repo for some of the functionality that has not been pushed into the other kubernetes repositories yet. In order to import the kubernetes/kubernetes repo, all of the associated repos have to pinned to the correct version specified by the kubernetes/kubernetes release. The ./hack/update-k8s-dependencies.sh updates all the dependencies to the those correct versions. Documentation Changes If you need to run the mkdocs server, you will need to do the following: Follow the instruction guide to install mkDocs Install the material theme with the following guide Run make plugin-docs to generate kubectl plugin documentation Afterwards, you can run mkdocs serve and access your documentation at http://127.0.0.1:8000/ If you don't want to setup mkDocs locally, the following docker command should suffice: docker run --rm -it -p 8000 :8000 -v ${ PWD } :/docs squidfunk/mkdocs-material","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"","title":"Contributing"},{"location":"CONTRIBUTING/#before-you-start","text":"Argo Rollouts is written in Golang. If you do not have a good grounding in Go, try out the tutorial .","title":"Before You Start"},{"location":"CONTRIBUTING/#pre-requisites","text":"Install: docker golang kubectl kustomize minikube or Docker for Desktop Argo Rollout additionally uses * golangci-lint to lint the project. Run the following commands to install them: go get -u github.com/golangci/golangci-lint/cmd/golangci-lint Brew users can quickly install the lot: brew install go kubectl kustomize Set up environment variables (e.g. is ~/.bashrc ): export GOPATH = ~/go export PATH = $PATH : $GOPATH /bin Checkout the code: go get -u github.com/argoproj/argo-rollouts cd ~/go/src/github.com/argoproj/argo-rollouts Run the following command to download all the dependencies: go mod download","title":"Pre-requisites"},{"location":"CONTRIBUTING/#building","text":"go.mod is used, so the go build/test commands automatically install the needed dependencies The make controller command will build the controller. make codegen - Runs the code generator that creates the informers, client, lister, and deepcopies from the types.go and modifies the open-api spec. This command fails if the user has not run go mod download to download all the dependencies of the project.","title":"Building"},{"location":"CONTRIBUTING/#running-tests","text":"To run unit tests: make test","title":"Running Tests"},{"location":"CONTRIBUTING/#running-locally","text":"It is much easier to run and debug if you run Argo Rollout in your local machine than in the Kubernetes cluster. cd ~/go/src/github.com/argoproj/argo-rollouts make controller ./dist/rollouts-controller","title":"Running Locally"},{"location":"CONTRIBUTING/#running-local-containers","text":"You may need to run containers locally, so here's how: Create login to Docker Hub, then login. docker login Add your username as the environment variable, e.g. to your ~/.bash_profile : export IMAGE_NAMESPACE = argoproj Build the images: DOCKER_PUSH = true make image Update the manifests: make manifests Install the manifests: kubectl -n argo-rollouts apply -f manifests/install.yaml","title":"Running Local Containers"},{"location":"CONTRIBUTING/#upgrading-kubernetes-libraries","text":"Argo Rollouts has a dependency on the kubernetes/kubernetes repo for some of the functionality that has not been pushed into the other kubernetes repositories yet. In order to import the kubernetes/kubernetes repo, all of the associated repos have to pinned to the correct version specified by the kubernetes/kubernetes release. The ./hack/update-k8s-dependencies.sh updates all the dependencies to the those correct versions.","title":"Upgrading Kubernetes Libraries"},{"location":"CONTRIBUTING/#documentation-changes","text":"If you need to run the mkdocs server, you will need to do the following: Follow the instruction guide to install mkDocs Install the material theme with the following guide Run make plugin-docs to generate kubectl plugin documentation Afterwards, you can run mkdocs serve and access your documentation at http://127.0.0.1:8000/ If you don't want to setup mkDocs locally, the following docker command should suffice: docker run --rm -it -p 8000 :8000 -v ${ PWD } :/docs squidfunk/mkdocs-material","title":"Documentation Changes"},{"location":"FAQ/","text":"FAQ General How does Argo Rollouts integrate with Argo CD? Argo CD understands the health of Argo Rollouts resources via Argo CD\u2019s Lua health check . These Health checks understand when the Argo Rollout objects are Progressing, Suspended, Degraded, or Healthy. Additionally, Argo CD has Lua based Resource Actions that can mutate an Argo Rollouts resource (i.e. unpause a Rollout). As a result, an operator can build automation to react to the states of the Argo Rollouts resources. For example, if a Rollout created by Argo CD is paused, Argo CD detects that and marks the Application as suspended. Once the new version is verified to be good, the operator can use Argo CD\u2019s resume resource action to unpause the Rollout so it can continue to make progress. Does Argo Rollout require a Service Mesh like Istio? Argo Rollouts does not require a service mesh or ingress controller to be used. In the absence of a traffic routing provider, Argo Rollouts manages the replica counts of the canary/stable ReplicaSets to achieve the desired canary weights. Normal Kubernetes Service routing (via kube-proxy) is used to split traffic between the ReplicaSets. Rollouts Which deployment strategies does Argo Rollouts support? Argo Rollouts supports BlueGreen, Canary, and Rolling Update. Additionally, Progressive Delivery features can be enabled on top of the blue-green/canary update, which further provides advanced deployment such as automated analysis and rollback. How does BlueGreen rollback work? A BlueGreen Rollout keeps the old ReplicaSet up and running for 30 seconds or the value of the scaleDownDelaySeconds. The controller tracks the remaining time before scaling down by adding an annotation called argo-rollouts.argoproj.io/scale-down-deadline to the old ReplicaSet. If the user applies the old Rollout manifest before the old ReplicaSet before it scales down, the controller does something called a fast rollback. The controller immediately switches the active service\u2019s selector back to the old ReplicaSet\u2019s rollout-pod-template-hash and removes the scaled down annotation from that ReplicaSet. The controller does not do any of the normal operations when trying to introduce a new version since it is trying to revert as fast as possible. A non-fast-track rollback occurs when the scale down annotation has past and the old ReplicaSet has been scaled down. In this case, the Rollout treats the ReplicaSet like any other new ReplicaSet and follows the usual procedure for deploying a new ReplicaSet. What is the argo-rollouts.argoproj.io/managed-by-rollouts annotation? Argo Rollouts adds an argo-rollouts.argoproj.io/managed-by-rollouts annotation to Services and Ingresses that the controller modifies. They are used when the Rollout managing these resources is deleted and the controller tries to revert them back into their previous state. Experiments Why doesn't my Experiment end? An Experiment\u2019s duration is controlled by the .spec.duration field and the analyses created for the Experiment. The .spec.duration indicates how long the ReplicaSets created by the Experiment should run. Once the duration passes, the experiment scales down the ReplicaSets it created and marks the AnalysisRuns successful unless the requiredForCompletion field is used in the Experiment. If enabled, the ReplicaSets are still scaled-down, but the Experiment does not finish until the Analysis Run finishes. Additionally, the .spec.duration is an optional field. If it\u2019s left unset, and the Experiment creates no AnalysisRuns, the ReplicaSets run indefinitely. The Experiment creates AnalysisRuns without the requiredForCompletion field, the Experiment fails only when the AnalysisRun created fails or errors out. If the requiredForCompletion field is set, the Experiment only marks itself as Successful and scales down the created ReplicaSets when the AnalysisRun finishes Successfully. Additionally, an Experiment ends if the .spec.terminate field is set to true regardless of the state of the Experiment. Analysis Why doesn't my AnalysisRun end? The AnalysisRun\u2019s duration is controlled by the metrics specified. Each Metric can specify an interval, count, and various limits (ConsecutiveErrorLimit, InconclusiveLimit, FailureLimit). If the interval is omitted, the AnalysisRun takes a single measurement. The count indicates how many measurements should be taken and causes the AnalysisRun to run indefinitely if omitted. The ConsecutiveErrorLimit, InconclusiveLimit, and FailureLimit define the thresholds allowed before putting the rollout into a completed state. Additionally, an AnalysisRun ends if the .spec.terminate field is set to true regardless of the state of the AnalysisRun. What is the difference between failures and errors? Failures are when the failure condition evaluates to true or an AnalysisRun without a failure condition evaluates the success condition to false. Errors are when the controller has any kind of issue with taking a measurement (i.e. invalid Prometheus URL).","title":"FAQ"},{"location":"FAQ/#faq","text":"","title":"FAQ"},{"location":"FAQ/#general","text":"","title":"General"},{"location":"FAQ/#how-does-argo-rollouts-integrate-with-argo-cd","text":"Argo CD understands the health of Argo Rollouts resources via Argo CD\u2019s Lua health check . These Health checks understand when the Argo Rollout objects are Progressing, Suspended, Degraded, or Healthy. Additionally, Argo CD has Lua based Resource Actions that can mutate an Argo Rollouts resource (i.e. unpause a Rollout). As a result, an operator can build automation to react to the states of the Argo Rollouts resources. For example, if a Rollout created by Argo CD is paused, Argo CD detects that and marks the Application as suspended. Once the new version is verified to be good, the operator can use Argo CD\u2019s resume resource action to unpause the Rollout so it can continue to make progress.","title":"How does Argo Rollouts integrate with Argo CD?"},{"location":"FAQ/#does-argo-rollout-require-a-service-mesh-like-istio","text":"Argo Rollouts does not require a service mesh or ingress controller to be used. In the absence of a traffic routing provider, Argo Rollouts manages the replica counts of the canary/stable ReplicaSets to achieve the desired canary weights. Normal Kubernetes Service routing (via kube-proxy) is used to split traffic between the ReplicaSets.","title":"Does Argo Rollout require a Service Mesh like Istio?"},{"location":"FAQ/#rollouts","text":"","title":"Rollouts"},{"location":"FAQ/#which-deployment-strategies-does-argo-rollouts-support","text":"Argo Rollouts supports BlueGreen, Canary, and Rolling Update. Additionally, Progressive Delivery features can be enabled on top of the blue-green/canary update, which further provides advanced deployment such as automated analysis and rollback.","title":"Which deployment strategies does Argo Rollouts support?"},{"location":"FAQ/#how-does-bluegreen-rollback-work","text":"A BlueGreen Rollout keeps the old ReplicaSet up and running for 30 seconds or the value of the scaleDownDelaySeconds. The controller tracks the remaining time before scaling down by adding an annotation called argo-rollouts.argoproj.io/scale-down-deadline to the old ReplicaSet. If the user applies the old Rollout manifest before the old ReplicaSet before it scales down, the controller does something called a fast rollback. The controller immediately switches the active service\u2019s selector back to the old ReplicaSet\u2019s rollout-pod-template-hash and removes the scaled down annotation from that ReplicaSet. The controller does not do any of the normal operations when trying to introduce a new version since it is trying to revert as fast as possible. A non-fast-track rollback occurs when the scale down annotation has past and the old ReplicaSet has been scaled down. In this case, the Rollout treats the ReplicaSet like any other new ReplicaSet and follows the usual procedure for deploying a new ReplicaSet.","title":"How does BlueGreen rollback work?"},{"location":"FAQ/#what-is-the-argo-rolloutsargoprojiomanaged-by-rollouts-annotation","text":"Argo Rollouts adds an argo-rollouts.argoproj.io/managed-by-rollouts annotation to Services and Ingresses that the controller modifies. They are used when the Rollout managing these resources is deleted and the controller tries to revert them back into their previous state.","title":"What is the argo-rollouts.argoproj.io/managed-by-rollouts annotation?"},{"location":"FAQ/#experiments","text":"","title":"Experiments"},{"location":"FAQ/#why-doesnt-my-experiment-end","text":"An Experiment\u2019s duration is controlled by the .spec.duration field and the analyses created for the Experiment. The .spec.duration indicates how long the ReplicaSets created by the Experiment should run. Once the duration passes, the experiment scales down the ReplicaSets it created and marks the AnalysisRuns successful unless the requiredForCompletion field is used in the Experiment. If enabled, the ReplicaSets are still scaled-down, but the Experiment does not finish until the Analysis Run finishes. Additionally, the .spec.duration is an optional field. If it\u2019s left unset, and the Experiment creates no AnalysisRuns, the ReplicaSets run indefinitely. The Experiment creates AnalysisRuns without the requiredForCompletion field, the Experiment fails only when the AnalysisRun created fails or errors out. If the requiredForCompletion field is set, the Experiment only marks itself as Successful and scales down the created ReplicaSets when the AnalysisRun finishes Successfully. Additionally, an Experiment ends if the .spec.terminate field is set to true regardless of the state of the Experiment.","title":"Why doesn't my Experiment end?"},{"location":"FAQ/#analysis","text":"","title":"Analysis"},{"location":"FAQ/#why-doesnt-my-analysisrun-end","text":"The AnalysisRun\u2019s duration is controlled by the metrics specified. Each Metric can specify an interval, count, and various limits (ConsecutiveErrorLimit, InconclusiveLimit, FailureLimit). If the interval is omitted, the AnalysisRun takes a single measurement. The count indicates how many measurements should be taken and causes the AnalysisRun to run indefinitely if omitted. The ConsecutiveErrorLimit, InconclusiveLimit, and FailureLimit define the thresholds allowed before putting the rollout into a completed state. Additionally, an AnalysisRun ends if the .spec.terminate field is set to true regardless of the state of the AnalysisRun.","title":"Why doesn't my AnalysisRun end?"},{"location":"FAQ/#what-is-the-difference-between-failures-and-errors","text":"Failures are when the failure condition evaluates to true or an AnalysisRun without a failure condition evaluates the success condition to false. Errors are when the controller has any kind of issue with taking a measurement (i.e. invalid Prometheus URL).","title":"What is the difference between failures and errors?"},{"location":"deployment-concepts/","text":"Deployment Concepts While the industry has agreed upon high-level definitions of various deployment strategies, the implementations of these strategies tend to differ across tooling. To make it clear how the Argo Rollouts will behave, here are the descriptions of the various deployment strategies implementations offered by the Argo Rollouts. Rolling Update A RollingUpdate slowly replaces the old version with the new version. As the new version comes up, the old version is scaled down in order to maintain the overall count of the application. This is the default strategy of the deployment object. Recreate A Recreate deployment deletes the old version of the application before bring up the new version. As a result, this ensures that two versions of the application never run at the same time, but there is downtime during the deployment. Blue Green A Blue Green deployment (which is sometimes referred to as a Red-Black) has both the new and old version of the application deployed at the same time. During this time, only the old version of the application will receive production traffic. This allows the developers to run tests against the new version before switching the live traffic to the new version. Canary A Canary deployment exposes a subset of users (usually 5%) to the new version of the application while serving the rest of the traffic to the old version. Once the new version is verified to be correct that the new version can gradually replace the old version. Service Meshes like Istio make canary deployments easily to rollout as the service mesh can filter the traffic for you.","title":"Concepts"},{"location":"deployment-concepts/#deployment-concepts","text":"While the industry has agreed upon high-level definitions of various deployment strategies, the implementations of these strategies tend to differ across tooling. To make it clear how the Argo Rollouts will behave, here are the descriptions of the various deployment strategies implementations offered by the Argo Rollouts.","title":"Deployment Concepts"},{"location":"deployment-concepts/#rolling-update","text":"A RollingUpdate slowly replaces the old version with the new version. As the new version comes up, the old version is scaled down in order to maintain the overall count of the application. This is the default strategy of the deployment object.","title":"Rolling Update"},{"location":"deployment-concepts/#recreate","text":"A Recreate deployment deletes the old version of the application before bring up the new version. As a result, this ensures that two versions of the application never run at the same time, but there is downtime during the deployment.","title":"Recreate"},{"location":"deployment-concepts/#blue-green","text":"A Blue Green deployment (which is sometimes referred to as a Red-Black) has both the new and old version of the application deployed at the same time. During this time, only the old version of the application will receive production traffic. This allows the developers to run tests against the new version before switching the live traffic to the new version.","title":"Blue Green"},{"location":"deployment-concepts/#canary","text":"A Canary deployment exposes a subset of users (usually 5%) to the new version of the application while serving the rest of the traffic to the old version. Once the new version is verified to be correct that the new version can gradually replace the old version. Service Meshes like Istio make canary deployments easily to rollout as the service mesh can filter the traffic for you.","title":"Canary"},{"location":"getting-started/","text":"Getting Started Requirements Installed kubectl command-line tool Have a kubeconfig file (default location is ~/.kube/config). Install Argo Rollouts Argo Rollouts can be installed at a cluster or namespace level. Important Since the API server rejects CRD manifests with unknown fields, the Argo Rollout's CRDs do not work with v1.13.x because they have a new field from the v1.14. Adding the --validate=false to the commands below allows the cluster to accept the Argo Rollouts CRDs. Cluster-Level installation kubectl create namespace argo-rollouts kubectl apply -n argo-rollouts -f https://raw.githubusercontent.com/argoproj/argo-rollouts/stable/manifests/install.yaml This will create a new namespace, argo-rollouts , where Argo Rollouts controller will live. On GKE, you will need grant your account the ability to create new cluster roles: kubectl create clusterrolebinding YOURNAME-cluster-admin-binding --clusterrole = cluster-admin --user = YOUREMAIL@gmail.com Note The cluster-level installation assumes that Argo Rollouts is deployed into the argo-rollouts namespace. If you would like to install Argo Rollouts in another namespace, you will need to modify the ClusterRoleBinding resource that binds the ClusterRole to the ServiceAcccount created. The namespace for the ServiceAccount referenced in the ClusterRoleBinding needs to be modified to match your desired namespace. Namespace-Level Installation kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/stable/manifests/namespace-install.yaml Converting Deployment to Rollout Converting a Deployment to a Rollout simply is a core design principle of Argo Rollouts. There are two key changes: Changing the apiVersion value to argoproj.io/v1alpha1 and changing the kind value from Deployment to Rollout Adding a new deployment strategy to the new Rollout. You can read up on the available strategies at Argo Rollouts section Below is an example of a Rollout YAML using the Canary strategy. apiVersion : argoproj.io/v1alpha1 # Changed from apps/v1 kind : Rollout # Changed from Deployment # ----- Everything below this comment is the same as a deployment ----- metadata : name : example-rollout spec : replicas : 5 selector : matchLabels : app : nginx template : metadata : labels : app : nginx spec : containers : - name : nginx image : nginx:1.15.4 ports : - containerPort : 80 minReadySeconds : 30 revisionHistoryLimit : 3 strategy : # ----- Everything above this comment are the same as a deployment ----- canary : # A new field that used to provide configurable options for a Canary strategy steps : - setWeight : 20 - pause : {} Updating the Rollout The initial creation of the above Rollout will bring up all 5 replicas of the Pod Spec listed. Since the rollout was not in a stable state beforehand (as it was just created), the rollout will skip the steps listed in the .spec.strategy.canary.steps field to first become stable. Once the new ReplicaSet is healthy, updating any field in the spec.template will cause the rollout to create a new ReplicaSet and execute the steps in spec.strategy.canary.steps to transition to the new version. To demonstrate this, we will update the rollout to use a new nginx image. You can either run kubectl edit rollout example-rollout and change the image from nginx:1.15.4 to nginx:1.15.5 , or run the following: $ kubectl patch rollout example-rollout --type merge -p { spec : { template : { spec : { containers : [{ name : nginx , image : nginx:1.15.5 }]}}}} Once the patch is applied, you can watch the new replicaset came up as healthy by running $ kubectl get replicaset -w -o wide Once that replicaset is healthy, the rollout will enter a paused state by adding a pause condition to .status.pauseConditions . The pause condition contains a reason and a pause start time. Promoting the rollout The rollout does not continue progessing to the new version until the pause conditon is removed from the status. Since the rollout YAML submitted does not have a duration within the pause step, the Rollout is paused indefinitely until a external process (i.e. a user or automated tool) removes the pause conditon. Argo Rollouts has a kubectl plugin to help automate operations like promoting a rollout through a step. The installation instructions are here . Once the plugin is installed, the user can run the following command to promote the rollout through the pause step: kubectl argo rollouts promote example-rollout At this point, the Rollout has executed all the steps to transition to a new version. As a result, the new ReplicaSet is considered the new stable ReplicaSet, and the previous ReplicaSet will be scaled down. The Rollout will repeat these steps when the Pod Spec Template is changed again. Going forward Check out the features page for more configuration options for a rollout.","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#requirements","text":"Installed kubectl command-line tool Have a kubeconfig file (default location is ~/.kube/config).","title":"Requirements"},{"location":"getting-started/#install-argo-rollouts","text":"Argo Rollouts can be installed at a cluster or namespace level. Important Since the API server rejects CRD manifests with unknown fields, the Argo Rollout's CRDs do not work with v1.13.x because they have a new field from the v1.14. Adding the --validate=false to the commands below allows the cluster to accept the Argo Rollouts CRDs.","title":"Install Argo Rollouts"},{"location":"getting-started/#cluster-level-installation","text":"kubectl create namespace argo-rollouts kubectl apply -n argo-rollouts -f https://raw.githubusercontent.com/argoproj/argo-rollouts/stable/manifests/install.yaml This will create a new namespace, argo-rollouts , where Argo Rollouts controller will live. On GKE, you will need grant your account the ability to create new cluster roles: kubectl create clusterrolebinding YOURNAME-cluster-admin-binding --clusterrole = cluster-admin --user = YOUREMAIL@gmail.com Note The cluster-level installation assumes that Argo Rollouts is deployed into the argo-rollouts namespace. If you would like to install Argo Rollouts in another namespace, you will need to modify the ClusterRoleBinding resource that binds the ClusterRole to the ServiceAcccount created. The namespace for the ServiceAccount referenced in the ClusterRoleBinding needs to be modified to match your desired namespace.","title":"Cluster-Level installation"},{"location":"getting-started/#namespace-level-installation","text":"kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/stable/manifests/namespace-install.yaml","title":"Namespace-Level Installation"},{"location":"getting-started/#converting-deployment-to-rollout","text":"Converting a Deployment to a Rollout simply is a core design principle of Argo Rollouts. There are two key changes: Changing the apiVersion value to argoproj.io/v1alpha1 and changing the kind value from Deployment to Rollout Adding a new deployment strategy to the new Rollout. You can read up on the available strategies at Argo Rollouts section Below is an example of a Rollout YAML using the Canary strategy. apiVersion : argoproj.io/v1alpha1 # Changed from apps/v1 kind : Rollout # Changed from Deployment # ----- Everything below this comment is the same as a deployment ----- metadata : name : example-rollout spec : replicas : 5 selector : matchLabels : app : nginx template : metadata : labels : app : nginx spec : containers : - name : nginx image : nginx:1.15.4 ports : - containerPort : 80 minReadySeconds : 30 revisionHistoryLimit : 3 strategy : # ----- Everything above this comment are the same as a deployment ----- canary : # A new field that used to provide configurable options for a Canary strategy steps : - setWeight : 20 - pause : {}","title":"Converting Deployment to Rollout"},{"location":"getting-started/#updating-the-rollout","text":"The initial creation of the above Rollout will bring up all 5 replicas of the Pod Spec listed. Since the rollout was not in a stable state beforehand (as it was just created), the rollout will skip the steps listed in the .spec.strategy.canary.steps field to first become stable. Once the new ReplicaSet is healthy, updating any field in the spec.template will cause the rollout to create a new ReplicaSet and execute the steps in spec.strategy.canary.steps to transition to the new version. To demonstrate this, we will update the rollout to use a new nginx image. You can either run kubectl edit rollout example-rollout and change the image from nginx:1.15.4 to nginx:1.15.5 , or run the following: $ kubectl patch rollout example-rollout --type merge -p { spec : { template : { spec : { containers : [{ name : nginx , image : nginx:1.15.5 }]}}}} Once the patch is applied, you can watch the new replicaset came up as healthy by running $ kubectl get replicaset -w -o wide Once that replicaset is healthy, the rollout will enter a paused state by adding a pause condition to .status.pauseConditions . The pause condition contains a reason and a pause start time.","title":"Updating the Rollout"},{"location":"getting-started/#promoting-the-rollout","text":"The rollout does not continue progessing to the new version until the pause conditon is removed from the status. Since the rollout YAML submitted does not have a duration within the pause step, the Rollout is paused indefinitely until a external process (i.e. a user or automated tool) removes the pause conditon. Argo Rollouts has a kubectl plugin to help automate operations like promoting a rollout through a step. The installation instructions are here . Once the plugin is installed, the user can run the following command to promote the rollout through the pause step: kubectl argo rollouts promote example-rollout At this point, the Rollout has executed all the steps to transition to a new version. As a result, the new ReplicaSet is considered the new stable ReplicaSet, and the previous ReplicaSet will be scaled down. The Rollout will repeat these steps when the Pod Spec Template is changed again.","title":"Promoting the rollout"},{"location":"getting-started/#going-forward","text":"Check out the features page for more configuration options for a rollout.","title":"Going forward"},{"location":"features/","text":"Overview The Rollout object has two available strategies: Canary and BlueGreen. Below are the links to the documenation for each strategy: Blue Green Canary The following describes all the available fields of a rollout: apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : example-rollout-canary spec : # Number of desired pods. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1. replicas : 5 # Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the ones affected by this rollout. It must match the pod template s labels.` selector : matchLabels : app : guestbook # Template describes the pods that will be created. Same as deployment template : spec : containers : - name : guestbook image : gcr.io/heptio-images/ks-guestbook-demo:0.1 # Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready) minReadySeconds : 30 # The number of old ReplicaSets to retain. If unspecified, will retain 10 old ReplicaSets revisionHistoryLimit : 3 # Indiciates if the rollout is paused paused : false # The maximum time in seconds for a rollout to make progress before it is considered to be failed. Argo Rollouts will continue to process failed rollouts and a condition with a ProgressDeadlineExceeded reason will be surfaced in the rollout status. Note that progress will not be estimated during the time a rollout is paused. Defaults to 600s. progressDeadlineSeconds : 600 # Field to specify the strategy to run strategy : blueGreen : # Name of the service that the rollout modifies as the active service. activeService : active-service # Pre-promotion analysis run prePromotionAnalysis : templates : - templateName : success-rate # template arguments args : - name : service-name value : guestbook-svc.default.svc.cluster.local # Name of the service that the rollout modifies as the preview service. previewService : preview-service # The number of replicas to run under the preview service before the switchover. Once the rollout is resumed the new replicaset will be full scaled up before the switch occurs +optional previewReplicaCount : 1 # Indicates if the rollout should automatically promote the new ReplicaSet to the active service or enter a paused state. If not specified, the default value is true. +optional autoPromotionEnabled : false # Automatically promotes the current ReplicaSet to active after the specified pause delay in seconds after the ReplicaSet becomes ready. If omitted, the Rollout enters and remains in a paused state until manually resumed by resetting spec.Paused to false. +optional autoPromotionSeconds : 30 # Adds a delay before scaling down the previous replicaset. If omitted, the Rollout waits 30 seconds before scaling down the previous ReplicaSet. A minimum of 30 seconds is recommended to ensure IP table propagation across the nodes in a cluster. See https://github.com/argoproj/argo-rollouts/issues/19#issuecomment-476329960 for more information scaleDownDelaySeconds : 30 # Limits the number of old RS that can run at once before getting scaled down. Defaults to nil scaleDownDelayRevisionLimit : 2 canary : # CanaryService holds the name of a service which selects pods with canary version and don t select any pods with stable version. +optional canaryService : canary-service # StableService holds the name of a service which selects pods with stable version and don t select any pods with canary version. +optional stableService : stable-service # The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total pods at the start of update (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. By default, a fixed value of 1 is used. Example: when this is set to 30%, the old RC can be scaled down by 30% immediately when the rolling update starts. Once new pods are ready, old RC can be scaled down further, followed by scaling up the new RC, ensuring that at least 70% of original number of pods are available at all times during the update. +optional maxUnavailable : 1 # The maximum number of pods that can be scheduled above the original number of pods. Value can be an absolute number (ex: 5) or a percentage of total pods at the start of the update (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. By default, a value of 1 is used. Example: when this is set to 30%, the new RC can be scaled up by 30% immediately when the rolling update starts. Once old pods have been killed, new RC can be scaled up further, ensuring that total number of pods running at any time during the update is atmost 130% of original pods. +optional maxSurge : 20% # Background analysis to run during the rollout analysis : templates : - templateName : success-rate # template arguments args : - name : service-name value : guestbook-svc.default.svc.cluster.local # Define the order of phases to execute the canary deployment +optional steps : # Sets the ratio of new replicasets to 20% - setWeight : 20 # Pauses the rollout for an hour - pause : duration : 1h # One hour - setWeight : 40 # Sets .spec.paused to true and waits until the field is changed back - pause : {} status : pauseConditions : - reason : StepPause startTime : 2019-10-00T1234 - reason : BlueGreenPause startTime : 2019-10-00T1234 - reason : AnalysisRunInconclusive startTime : 2019-10-00T1234","title":"Overview"},{"location":"features/#overview","text":"The Rollout object has two available strategies: Canary and BlueGreen. Below are the links to the documenation for each strategy: Blue Green Canary The following describes all the available fields of a rollout: apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : example-rollout-canary spec : # Number of desired pods. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1. replicas : 5 # Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the ones affected by this rollout. It must match the pod template s labels.` selector : matchLabels : app : guestbook # Template describes the pods that will be created. Same as deployment template : spec : containers : - name : guestbook image : gcr.io/heptio-images/ks-guestbook-demo:0.1 # Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready) minReadySeconds : 30 # The number of old ReplicaSets to retain. If unspecified, will retain 10 old ReplicaSets revisionHistoryLimit : 3 # Indiciates if the rollout is paused paused : false # The maximum time in seconds for a rollout to make progress before it is considered to be failed. Argo Rollouts will continue to process failed rollouts and a condition with a ProgressDeadlineExceeded reason will be surfaced in the rollout status. Note that progress will not be estimated during the time a rollout is paused. Defaults to 600s. progressDeadlineSeconds : 600 # Field to specify the strategy to run strategy : blueGreen : # Name of the service that the rollout modifies as the active service. activeService : active-service # Pre-promotion analysis run prePromotionAnalysis : templates : - templateName : success-rate # template arguments args : - name : service-name value : guestbook-svc.default.svc.cluster.local # Name of the service that the rollout modifies as the preview service. previewService : preview-service # The number of replicas to run under the preview service before the switchover. Once the rollout is resumed the new replicaset will be full scaled up before the switch occurs +optional previewReplicaCount : 1 # Indicates if the rollout should automatically promote the new ReplicaSet to the active service or enter a paused state. If not specified, the default value is true. +optional autoPromotionEnabled : false # Automatically promotes the current ReplicaSet to active after the specified pause delay in seconds after the ReplicaSet becomes ready. If omitted, the Rollout enters and remains in a paused state until manually resumed by resetting spec.Paused to false. +optional autoPromotionSeconds : 30 # Adds a delay before scaling down the previous replicaset. If omitted, the Rollout waits 30 seconds before scaling down the previous ReplicaSet. A minimum of 30 seconds is recommended to ensure IP table propagation across the nodes in a cluster. See https://github.com/argoproj/argo-rollouts/issues/19#issuecomment-476329960 for more information scaleDownDelaySeconds : 30 # Limits the number of old RS that can run at once before getting scaled down. Defaults to nil scaleDownDelayRevisionLimit : 2 canary : # CanaryService holds the name of a service which selects pods with canary version and don t select any pods with stable version. +optional canaryService : canary-service # StableService holds the name of a service which selects pods with stable version and don t select any pods with canary version. +optional stableService : stable-service # The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total pods at the start of update (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. By default, a fixed value of 1 is used. Example: when this is set to 30%, the old RC can be scaled down by 30% immediately when the rolling update starts. Once new pods are ready, old RC can be scaled down further, followed by scaling up the new RC, ensuring that at least 70% of original number of pods are available at all times during the update. +optional maxUnavailable : 1 # The maximum number of pods that can be scheduled above the original number of pods. Value can be an absolute number (ex: 5) or a percentage of total pods at the start of the update (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. By default, a value of 1 is used. Example: when this is set to 30%, the new RC can be scaled up by 30% immediately when the rolling update starts. Once old pods have been killed, new RC can be scaled up further, ensuring that total number of pods running at any time during the update is atmost 130% of original pods. +optional maxSurge : 20% # Background analysis to run during the rollout analysis : templates : - templateName : success-rate # template arguments args : - name : service-name value : guestbook-svc.default.svc.cluster.local # Define the order of phases to execute the canary deployment +optional steps : # Sets the ratio of new replicasets to 20% - setWeight : 20 # Pauses the rollout for an hour - pause : duration : 1h # One hour - setWeight : 40 # Sets .spec.paused to true and waits until the field is changed back - pause : {} status : pauseConditions : - reason : StepPause startTime : 2019-10-00T1234 - reason : BlueGreenPause startTime : 2019-10-00T1234 - reason : AnalysisRunInconclusive startTime : 2019-10-00T1234","title":"Overview"},{"location":"features/analysis/","text":"Analysis Progressive Delivery Argo Rollouts provides several ways to perform analysis to drive progressive delivery. This document describes how to achieve various forms of progressive delivery, varying the point in time analysis is performed, it's frequency, and occurrence. Custom Resource Definitions CRD Description Rollout A Rollout acts as a drop-in replacement for a Deployment resource. It provides additional blueGreen and canary update strategies. These strategies can create AnalysisRuns and Experiments during the update, which will progress the update, or abort it. AnalysisTemplate An AnalysisTemplate is a template spec which defines how to perform a canary analysis, such as the metrics which it should perform, its frequency, and the values which are considered successful or failed. AnalysisTemplates may be parameterized with inputs values. AnalysisRun An AnalysisRun is an instantiation of an AnalysisTemplate . AnalysisRuns are like Jobs in that they eventually complete. Completed runs are considered Successful, Failed, or Inconclusive, and the result of the run affect if the Rollout's update will continue, abort, or pause, respectively. Experiment An Experiment is limited run of one or more ReplicaSets for the purposes of analysis. Experiments typically run for a pre-determined duration, but can also run indefinitely until stopped. Experiments may reference an AnalysisTemplate to run during or after the experiment. The canonical use case for an Experiment is to start a baseline and canary deployment in parallel, and compare the metrics produced by the baseline and canary pods for an equal comparison. Background Analysis Analysis can be run in the background -- while the canary is progressing through its rollout steps. The following example gradually increments the canary weight by 20% every 10 minutes until it reaches 100%. In the background, an AnalysisRun is started based on the AnalysisTemplate named success-rate . The success-rate template queries a prometheus server, measuring the HTTP success rates at 5 minute intervals/samples. It has no end time, and continues until stopped or failed. If the metric is measured to be less than 95%, and there are three such measurements, the analysis is considered Failed. The failed analysis causes the Rollout to abort, setting the canary weight back to zero, and the Rollout would be considered in a Degraded . Otherwise, if the rollout completes all of its canary steps, the rollout is considered successful and the analysis run is stopped by the controller. This example highlights: Background analysis style of progressive delivery Using a Prometheus query to perform a measurement The ability to parameterize the analysis Delay starting the analysis run until step 3 (Set Weight 40%) Rollout apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : guestbook spec : ... strategy : canary : analysis : templates : - templateName : success-rate startingStep : 2 # delay starting analysis run # until setWeight: 40% args : - name : service-name value : guestbook-svc.default.svc.cluster.local steps : - setWeight : 20 - pause : { duration : 10m } - setWeight : 40 - pause : { duration : 10m } - setWeight : 60 - pause : { duration : 10m } - setWeight : 80 - pause : { duration : 10m } AnalysisTemplate apiVersion : argoproj.io/v1alpha1 kind : AnalysisTemplate metadata : name : success-rate spec : args : - name : service-name metrics : - name : success-rate interval : 5m successCondition : result = 0.95 failureLimit : 3 provider : prometheus : address : http://prometheus.example.com:9090 query : | sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} ,response_code!~ 5.* }[5m] )) / sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} }[5m] )) Note Previously, the Rollout analysis section had a field called \" templateName \" where a user would specify a single AnalysisTemplate. This field has be depreciated in lieu of the templates field, and the field will be removed in v0.9.0. Analysis at a Predefined Step Analysis can also be performed as a rollout step as a \"analysis\" step. When analysis is performed as a step, an AnalysisRun is started when the step is reached, and blocks the rollout until the run is completed. The success or failure of the analysis run decides if the rollout will proceed to the next step, or abort the rollout completely. This example sets the canary weight to 20%, pauses for 5 minutes, then runs an analysis. If the analysis was successful, continues with rollout, otherwise aborts. This example demonstrates: The ability to invoke an analysis in-line as part of steps apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : guestbook spec : ... strategy : canary : steps : - setWeight : 20 - pause : { duration : 5m } - analysis : templates : - templateName : success-rate args : - name : service-name value : guestbook-svc.default.svc.cluster.local Note Previously, the Rollout analysis section had a field called \" templateName \" where a user would specify a single AnalysisTemplate. This field has be depreciated in lieu of the templates field, and the field will be removed in v0.9.0. In this example, the AnalysisTemplate is identical to the background analysis example, but since no interval is specified, the analysis will perform a single measurement and complete. apiVersion : argoproj.io/v1alpha1 kind : AnalysisTemplate metadata : name : success-rate spec : args : - name : service-name metrics : - name : success-rate successCondition : result = 0.95 provider : prometheus : address : http://prometheus.example.com:9090 query : | sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} ,response_code!~ 5.* }[5m] )) / sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} }[5m] )) Multiple measurements can be performed over a longer duration period, by specifying the count and interval fields: metrics : - name : success-rate successCondition : result = 0.95 interval : 60s count : 5 provider : prometheus : address : http://prometheus.example.com:9090 query : ... Analysis with Multiple Templates A Rollout can reference multiple AnalysisTemplates when constructing an AnalysisRun. This allows users to compose analysis from multiple AnalysisTemplates. If multiple templates are referenced, then the controller will merge the templates together. The controller combines the metrics and args fields of all the templates. Rollout apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : guestbook spec : ... strategy : canary : analysis : templates : - templateName : success-rate - templateName : error-rate args : - name : service-name value : guestbook-svc.default.svc.cluster.local AnalysisTemplate apiVersion : argoproj.io/v1alpha1 kind : AnalysisTemplate metadata : name : success-rate spec : args : - name : service-name metrics : - name : success-rate interval : 5m successCondition : result = 0.95 failureLimit : 3 provider : prometheus : address : http://prometheus.example.com:9090 query : | sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} ,response_code!~ 5.* }[5m] )) / sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} }[5m] )) --- apiVersion : argoproj.io/v1alpha1 kind : AnalysisTemplate metadata : name : error-rate spec : args : - name : service-name metrics : - name : error-rate interval : 5m successCondition : result = 0.95 failureLimit : 3 provider : prometheus : address : http://prometheus.example.com:9090 query : | sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} ,response_code=~ 5.* }[5m] )) / sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} }[5m] )) AnalysisRun # NOTE: The rollouts controller will create this resource apiVersion : argoproj.io/v1alpha1 kind : AnalysisRun metadata : name : guestbook-CurrentPodHash-multiple-templates spec : args : - name : service-name value : guestbook-svc.default.svc.cluster.local metrics : - name : success-rate interval : 5m successCondition : result = 0.95 failureLimit : 3 provider : prometheus : address : http://prometheus.example.com:9090 query : | sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} ,response_code!~ 5.* }[5m] )) / sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} }[5m] )) - name : error-rate interval : 5m successCondition : result = 0.95 failureLimit : 3 provider : prometheus : address : http://prometheus.example.com:9090 query : | sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} ,response_code=~ 5.* }[5m] )) / sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} }[5m] )) Note The controller will error when merging the templates if: Multiple metrics in the templates have the same name Two arguments with the same name both have values Analysis Template Arguments AnalysisTemplates may declare a set of arguments that can be passed by Rollouts. The args can then be used as in metrics configuration and are resolved at the time the AnalysisRun is created. Argument placeholders are defined as {{ args. name }} . apiVersion : argoproj.io/v1alpha1 kind : AnalysisTemplate metadata : name : args-example spec : args : # required - name : service-name - name : stable-hash - name : latest-hash # optional - name : api-url value : http://example/measure # from secret - name : api-token valueFrom : secretKeyRef : name : token-secret key : apiToken metrics : - name : webmetric successCondition : result == true provider : web : # paceholders are resolved when an AnalysisRun is created url : {{ args.api-url }}?service={{ args.service-name }} headers : - key : Authorization value : Bearer {{ args.api-token }} jsonPath : {$.results.ok} Analysis arguments defined in a Rollout are merged with the args from the AnalysisTemplate when the AnalysisRun is created. apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : guestbook spec : ... strategy : canary : analysis : templates : - templateName : args-example args : # required value - name : service-name value : guestbook-svc.default.svc.cluster.local # override default value - name : api-url value : http://other-api # pod template hash from the stable ReplicaSet - name : stable-hash valueFrom : podTemplateHashValue : Stable # pod template hash from the latest ReplicaSet - name : latest-hash valueFrom : podTemplateHashValue : Latest BlueGreen Pre Promotion Analysis A Rollout using the BlueGreen strategy can launch an AnalysisRun before it switches traffic to the new version. The AnalysisRun can be used to block the Service selector switch until the AnalysisRun finishes successful. The success or failure of the analysis run decides if the Rollout will switch traffic, or abort the Rollout completely. apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : guestbook spec : ... strategy : blueGreen : activeService : active-svc previewService : preview-svc prePromotionAnalysis : templates : - templateName : smoke-tests args : - name : service-name value : preview-svc.default.svc.cluster.local In this example, the Rollout is creating a AnalysisRun once the new version has all the pods available. The Rollout will not switch traffic to the new version until the analysis run finishes successfully. Note: if the autoPromotionSeconds field is specified and the Rollout has waited auto promotion seconds amount of time, the Rollout marks the AnalysisRun successful and switches the traffic to a new version automatically. If the AnalysisRun completes before then, the Rollout will not create another AnalysisRun and wait out the rest of the autoPromotionSeconds . BlueGreen Post Promotion Analysis A Rollout using a BlueGreen strategy can launch an analysis run after the traffic switch to new version. If the analysis run fails or errors out, the Rollout enters an aborted state and switch traffic back to the previous stable Replicaset. If scaleDownDelaySeconds is specified, the controller will cancel any AnalysisRuns at time of scaleDownDelay to scale down the ReplicaSet. If it is omitted, and post analysis is specified, it will scale down the ReplicaSet only after the AnalysisRun completes (with a minimum of 30 seconds). apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : guestbook spec : ... strategy : blueGreen : activeService : active-svc previewService : preview-svc scaleDownDelaySeconds : 600 # 10 minutes postPromotionAnalysis : templates : - templateName : smoke-tests args : - name : service-name value : preview-svc.default.svc.cluster.local Failure Conditions failureCondition can be used to cause an analysis run to fail. The following example continually polls a prometheus server to get the total number of errors every 5 minutes, causing the analysis run to fail if 10 or more errors were encountered. metrics : - name : total-errors interval : 5m failureCondition : result = 10 failureLimit : 3 provider : prometheus : address : http://prometheus.example.com:9090 query : | sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} ,response_code~ 5.* }[5m] )) Inconclusive Runs Analysis runs can also be considered Inconclusive , which indicates the run was neither successful, nor failed. Inconclusive runs causes a rollout to become paused at its current step. Manual intervention is then needed to either resume the rollout, or abort. One example of how analysis runs could become Inconclusive , is when a metric defines no success or failure conditions. metrics : - name : my-query provider : prometheus : address : http://prometheus.example.com:9090 query : ... Inconclusive analysis runs might also happen when both success and failure conditions are specified, but the measurement value did not meet either condition. metrics : - name : success-rate successCondition : result = 0.90 failureCondition : result 0.50 provider : prometheus : address : http://prometheus.example.com:9090 query : ... A use case for having Inconclusive analysis runs are to enable Argo Rollouts to automate the execution of analysis runs, and collect the measurement, but still allow human judgement to decide whether or not measurement value is acceptable and decide to proceed or abort. Delay Analysis Runs If the analysis run does not need to start immediately (i.e give the metric provider time to collect metrics on the canary version), Analysis Runs can delay the specific metric analysis. Each metric can be configured to have a different delay. In additional to the metric specific delays, the rollouts with background analysis can delay creating an analysis run until a certain step is reached Delaying a specific analysis metric: metrics : - name : success-rate initialDelay : 5m # Do not start this analysis until 5 minutes after the analysis run starts successCondition : result = 0.90 provider : prometheus : address : http://prometheus.example.com:9090 query : ... Delaying starting background analysis run until step 3 (Set Weight 40%): apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : guestbook spec : ... strategy : canary : analysis : templates : - templateName : success-rate startingStep : 2 steps : - setWeight : 20 - pause : { duration : 10m } - setWeight : 40 - pause : { duration : 10m } Experimentation (e.g. Mann-Whitney Analysis) Analysis can also be done as part of an Experiment. This example starts both a canary and baseline ReplicaSet. The ReplicaSets run for 1 hour, then scale down to zero. Call out to Kayenta to perform Mann-Whintney analysis against the two pods. Demonstrates ability to start a short-lived experiment and an asynchronous analysis. This example demonstrates: The ability to start an Experiment as part of rollout steps, which launches multiple ReplicaSets (e.g. baseline canary) The ability to reference and supply pod-template-hash to an AnalysisRun Kayenta metrics Rollout apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : guestbook labels : app : guestbook spec : ... strategy : canary : steps : - experiment : duration : 1h templates : - name : baseline specRef : stable - name : canary specRef : canary analysis : templateName : mann-whitney args : - name : stable-hash valueFrom : podTemplateHashValue : Stable - name : canary-hash valueFrom : podTemplateHashValue : Latest AnalysisTemplate apiVersion : argoproj.io/v1alpha1 kind : AnalysisTemplate metadata : name : mann-whitney spec : args : - name : start-time - name : end-time - name : stable-hash - name : canary-hash metrics : - name : mann-whitney provider : kayenta : address : https://kayenta.example.com application : guestbook canaryConfigName : my-test thresholds : pass : 90 marginal : 75 scopes : - name : default controlScope : scope : app=guestbook and rollouts-pod-template-hash={{args.stable-hash}} step : 60 start : {{args.start-time}} end : {{args.end-time}} experimentScope : scope : app=guestbook and rollouts-pod-template-hash={{args.canary-hash}} step : 60 start : {{args.start-time}} end : {{args.end-time}} Experiment apiVersion : argoproj.io/v1alpha1 kind : Experiment name : name : guestbook-6c54544bf9-0 spec : duration : 1h templates : - name : baseline replicas : 1 spec : containers : - name : guestbook image : guesbook:v1 - name : canary replicas : 1 spec : containers : - name : guestbook image : guesbook:v2 analysis : templateName : mann-whitney args : - name : start-time value : {{experiment.availableAt}} - name : end-time value : {{experiment.finishedAt}} In order to perform multiple kayenta runs over some time duration, the interval and count fields can be supplied. When the start and end fields are omitted from the kayenta scopes, the values will be implicitly decided as: start = if lookback: true start of analysis, otherwise current time - interval end = current time apiVersion : argoproj.io/v1alpha1 kind : AnalysisTemplate metadata : name : mann-whitney spec : args : - name : stable-hash - name : canary-hash metrics : - name : mann-whitney provider : kayenta : address : https://kayenta.intuit.com application : guestbook canaryConfigName : my-test interval : 3600 count : 3 # loopback will cause start time value to be equal to start of analysis # lookback: true thresholds : pass : 90 marginal : 75 scopes : - name : default controlScope : scope : app=guestbook and rollouts-pod-template-hash={{args.stable-hash}} step : 60 experimentScope : scope : app=guestbook and rollouts-pod-template-hash={{args.canary-hash}} step : 60 Run Experiment Indefinitely Experiments can run for an indefinite duration by omitting the duration field. Indefinite experiments would be stopped externally, or through the completion of a referenced analysis. Job Metrics A Kubernetes Job can be used to run analysis. When a Job is used, the metric is considered successful if the Job completes and had an exit code of zero, otherwise it is failed. metrics : - name : test provider : job : backoffLimit : 1 spec : template : spec : containers : - name : test image : my-image:latest command : [ my-test-script , my-service.default.svc.cluster.local ] restartPolicy : Never Wavefront Metrics A Wavefront query can be used to obtain measurements for analysis. apiVersion : argoproj.io/v1alpha1 kind : AnalysisTemplate metadata : name : success-rate spec : args : - name : service-name metrics : - name : success-rate interval : 5m successCondition : result = 0.95 failureLimit : 3 provider : wavefront : address : example.wavefront.com query : | sum(rate( 5m, ts( istio.requestcount.count , response_code!=500 and destination_service= {{args.service-name}} ))) / sum(rate( 5m, ts( istio.requestcount.count , reporter=client and destination_service= {{args.service-name}} ))) Wavefront api tokens can be configured in a kubernetes secret in argo-rollouts namespace. apiVersion : v1 kind : Secret metadata : name : wavefront-api-tokens type : Opaque data : example1.wavefront.com : token1 example2.wavefront.com : token2 Web Metrics A webhook can be used to call out to some external service to obtain the measurement. This example makes a HTTP GET request to some URL. The webhook response must return JSON content. The result of the jsonPath expression will be assigned to the result variable that can be referenced in the successCondition and failureCondition expressions. metrics : - name : webmetric successCondition : result == true provider : web : url : http://my-server.com/api/v1/measurement?service={{ args.service-name }} timeoutSeconds : 20 # defaults to 10 seconds headers : - key : Authorization value : Bearer {{ args.api-token }} jsonPath : {$.results.ok} In this example, the measurement is successful if the json response returns \"true\" for the nested ok field. { results : { ok : true , successPercent : 0.95 } } For success conditions that need to evaluate a numeric return value the asInt or asFloat functions can be used to convert the result value. metrics : - name : webmetric successCondition : asFloat(result) = 0.90 provider : web : url : http://my-server.com/api/v1/measurement?service={{ args.service-name }} headers : - key : Authorization value : Bearer {{ args.api-token }} jsonPath : {$.results.successPercent}","title":"Analysis"},{"location":"features/analysis/#analysis-progressive-delivery","text":"Argo Rollouts provides several ways to perform analysis to drive progressive delivery. This document describes how to achieve various forms of progressive delivery, varying the point in time analysis is performed, it's frequency, and occurrence.","title":"Analysis &amp; Progressive Delivery"},{"location":"features/analysis/#custom-resource-definitions","text":"CRD Description Rollout A Rollout acts as a drop-in replacement for a Deployment resource. It provides additional blueGreen and canary update strategies. These strategies can create AnalysisRuns and Experiments during the update, which will progress the update, or abort it. AnalysisTemplate An AnalysisTemplate is a template spec which defines how to perform a canary analysis, such as the metrics which it should perform, its frequency, and the values which are considered successful or failed. AnalysisTemplates may be parameterized with inputs values. AnalysisRun An AnalysisRun is an instantiation of an AnalysisTemplate . AnalysisRuns are like Jobs in that they eventually complete. Completed runs are considered Successful, Failed, or Inconclusive, and the result of the run affect if the Rollout's update will continue, abort, or pause, respectively. Experiment An Experiment is limited run of one or more ReplicaSets for the purposes of analysis. Experiments typically run for a pre-determined duration, but can also run indefinitely until stopped. Experiments may reference an AnalysisTemplate to run during or after the experiment. The canonical use case for an Experiment is to start a baseline and canary deployment in parallel, and compare the metrics produced by the baseline and canary pods for an equal comparison.","title":"Custom Resource Definitions"},{"location":"features/analysis/#background-analysis","text":"Analysis can be run in the background -- while the canary is progressing through its rollout steps. The following example gradually increments the canary weight by 20% every 10 minutes until it reaches 100%. In the background, an AnalysisRun is started based on the AnalysisTemplate named success-rate . The success-rate template queries a prometheus server, measuring the HTTP success rates at 5 minute intervals/samples. It has no end time, and continues until stopped or failed. If the metric is measured to be less than 95%, and there are three such measurements, the analysis is considered Failed. The failed analysis causes the Rollout to abort, setting the canary weight back to zero, and the Rollout would be considered in a Degraded . Otherwise, if the rollout completes all of its canary steps, the rollout is considered successful and the analysis run is stopped by the controller. This example highlights: Background analysis style of progressive delivery Using a Prometheus query to perform a measurement The ability to parameterize the analysis Delay starting the analysis run until step 3 (Set Weight 40%) Rollout apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : guestbook spec : ... strategy : canary : analysis : templates : - templateName : success-rate startingStep : 2 # delay starting analysis run # until setWeight: 40% args : - name : service-name value : guestbook-svc.default.svc.cluster.local steps : - setWeight : 20 - pause : { duration : 10m } - setWeight : 40 - pause : { duration : 10m } - setWeight : 60 - pause : { duration : 10m } - setWeight : 80 - pause : { duration : 10m } AnalysisTemplate apiVersion : argoproj.io/v1alpha1 kind : AnalysisTemplate metadata : name : success-rate spec : args : - name : service-name metrics : - name : success-rate interval : 5m successCondition : result = 0.95 failureLimit : 3 provider : prometheus : address : http://prometheus.example.com:9090 query : | sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} ,response_code!~ 5.* }[5m] )) / sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} }[5m] )) Note Previously, the Rollout analysis section had a field called \" templateName \" where a user would specify a single AnalysisTemplate. This field has be depreciated in lieu of the templates field, and the field will be removed in v0.9.0.","title":"Background Analysis"},{"location":"features/analysis/#analysis-at-a-predefined-step","text":"Analysis can also be performed as a rollout step as a \"analysis\" step. When analysis is performed as a step, an AnalysisRun is started when the step is reached, and blocks the rollout until the run is completed. The success or failure of the analysis run decides if the rollout will proceed to the next step, or abort the rollout completely. This example sets the canary weight to 20%, pauses for 5 minutes, then runs an analysis. If the analysis was successful, continues with rollout, otherwise aborts. This example demonstrates: The ability to invoke an analysis in-line as part of steps apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : guestbook spec : ... strategy : canary : steps : - setWeight : 20 - pause : { duration : 5m } - analysis : templates : - templateName : success-rate args : - name : service-name value : guestbook-svc.default.svc.cluster.local Note Previously, the Rollout analysis section had a field called \" templateName \" where a user would specify a single AnalysisTemplate. This field has be depreciated in lieu of the templates field, and the field will be removed in v0.9.0. In this example, the AnalysisTemplate is identical to the background analysis example, but since no interval is specified, the analysis will perform a single measurement and complete. apiVersion : argoproj.io/v1alpha1 kind : AnalysisTemplate metadata : name : success-rate spec : args : - name : service-name metrics : - name : success-rate successCondition : result = 0.95 provider : prometheus : address : http://prometheus.example.com:9090 query : | sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} ,response_code!~ 5.* }[5m] )) / sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} }[5m] )) Multiple measurements can be performed over a longer duration period, by specifying the count and interval fields: metrics : - name : success-rate successCondition : result = 0.95 interval : 60s count : 5 provider : prometheus : address : http://prometheus.example.com:9090 query : ...","title":"Analysis at a Predefined Step"},{"location":"features/analysis/#analysis-with-multiple-templates","text":"A Rollout can reference multiple AnalysisTemplates when constructing an AnalysisRun. This allows users to compose analysis from multiple AnalysisTemplates. If multiple templates are referenced, then the controller will merge the templates together. The controller combines the metrics and args fields of all the templates. Rollout apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : guestbook spec : ... strategy : canary : analysis : templates : - templateName : success-rate - templateName : error-rate args : - name : service-name value : guestbook-svc.default.svc.cluster.local AnalysisTemplate apiVersion : argoproj.io/v1alpha1 kind : AnalysisTemplate metadata : name : success-rate spec : args : - name : service-name metrics : - name : success-rate interval : 5m successCondition : result = 0.95 failureLimit : 3 provider : prometheus : address : http://prometheus.example.com:9090 query : | sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} ,response_code!~ 5.* }[5m] )) / sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} }[5m] )) --- apiVersion : argoproj.io/v1alpha1 kind : AnalysisTemplate metadata : name : error-rate spec : args : - name : service-name metrics : - name : error-rate interval : 5m successCondition : result = 0.95 failureLimit : 3 provider : prometheus : address : http://prometheus.example.com:9090 query : | sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} ,response_code=~ 5.* }[5m] )) / sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} }[5m] )) AnalysisRun # NOTE: The rollouts controller will create this resource apiVersion : argoproj.io/v1alpha1 kind : AnalysisRun metadata : name : guestbook-CurrentPodHash-multiple-templates spec : args : - name : service-name value : guestbook-svc.default.svc.cluster.local metrics : - name : success-rate interval : 5m successCondition : result = 0.95 failureLimit : 3 provider : prometheus : address : http://prometheus.example.com:9090 query : | sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} ,response_code!~ 5.* }[5m] )) / sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} }[5m] )) - name : error-rate interval : 5m successCondition : result = 0.95 failureLimit : 3 provider : prometheus : address : http://prometheus.example.com:9090 query : | sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} ,response_code=~ 5.* }[5m] )) / sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} }[5m] )) Note The controller will error when merging the templates if: Multiple metrics in the templates have the same name Two arguments with the same name both have values","title":"Analysis with Multiple Templates"},{"location":"features/analysis/#analysis-template-arguments","text":"AnalysisTemplates may declare a set of arguments that can be passed by Rollouts. The args can then be used as in metrics configuration and are resolved at the time the AnalysisRun is created. Argument placeholders are defined as {{ args. name }} . apiVersion : argoproj.io/v1alpha1 kind : AnalysisTemplate metadata : name : args-example spec : args : # required - name : service-name - name : stable-hash - name : latest-hash # optional - name : api-url value : http://example/measure # from secret - name : api-token valueFrom : secretKeyRef : name : token-secret key : apiToken metrics : - name : webmetric successCondition : result == true provider : web : # paceholders are resolved when an AnalysisRun is created url : {{ args.api-url }}?service={{ args.service-name }} headers : - key : Authorization value : Bearer {{ args.api-token }} jsonPath : {$.results.ok} Analysis arguments defined in a Rollout are merged with the args from the AnalysisTemplate when the AnalysisRun is created. apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : guestbook spec : ... strategy : canary : analysis : templates : - templateName : args-example args : # required value - name : service-name value : guestbook-svc.default.svc.cluster.local # override default value - name : api-url value : http://other-api # pod template hash from the stable ReplicaSet - name : stable-hash valueFrom : podTemplateHashValue : Stable # pod template hash from the latest ReplicaSet - name : latest-hash valueFrom : podTemplateHashValue : Latest","title":"Analysis Template Arguments"},{"location":"features/analysis/#bluegreen-pre-promotion-analysis","text":"A Rollout using the BlueGreen strategy can launch an AnalysisRun before it switches traffic to the new version. The AnalysisRun can be used to block the Service selector switch until the AnalysisRun finishes successful. The success or failure of the analysis run decides if the Rollout will switch traffic, or abort the Rollout completely. apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : guestbook spec : ... strategy : blueGreen : activeService : active-svc previewService : preview-svc prePromotionAnalysis : templates : - templateName : smoke-tests args : - name : service-name value : preview-svc.default.svc.cluster.local In this example, the Rollout is creating a AnalysisRun once the new version has all the pods available. The Rollout will not switch traffic to the new version until the analysis run finishes successfully. Note: if the autoPromotionSeconds field is specified and the Rollout has waited auto promotion seconds amount of time, the Rollout marks the AnalysisRun successful and switches the traffic to a new version automatically. If the AnalysisRun completes before then, the Rollout will not create another AnalysisRun and wait out the rest of the autoPromotionSeconds .","title":"BlueGreen Pre Promotion Analysis"},{"location":"features/analysis/#bluegreen-post-promotion-analysis","text":"A Rollout using a BlueGreen strategy can launch an analysis run after the traffic switch to new version. If the analysis run fails or errors out, the Rollout enters an aborted state and switch traffic back to the previous stable Replicaset. If scaleDownDelaySeconds is specified, the controller will cancel any AnalysisRuns at time of scaleDownDelay to scale down the ReplicaSet. If it is omitted, and post analysis is specified, it will scale down the ReplicaSet only after the AnalysisRun completes (with a minimum of 30 seconds). apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : guestbook spec : ... strategy : blueGreen : activeService : active-svc previewService : preview-svc scaleDownDelaySeconds : 600 # 10 minutes postPromotionAnalysis : templates : - templateName : smoke-tests args : - name : service-name value : preview-svc.default.svc.cluster.local","title":"BlueGreen Post Promotion Analysis"},{"location":"features/analysis/#failure-conditions","text":"failureCondition can be used to cause an analysis run to fail. The following example continually polls a prometheus server to get the total number of errors every 5 minutes, causing the analysis run to fail if 10 or more errors were encountered. metrics : - name : total-errors interval : 5m failureCondition : result = 10 failureLimit : 3 provider : prometheus : address : http://prometheus.example.com:9090 query : | sum(irate( istio_requests_total{reporter= source ,destination_service=~ {{args.service-name}} ,response_code~ 5.* }[5m] ))","title":"Failure Conditions"},{"location":"features/analysis/#inconclusive-runs","text":"Analysis runs can also be considered Inconclusive , which indicates the run was neither successful, nor failed. Inconclusive runs causes a rollout to become paused at its current step. Manual intervention is then needed to either resume the rollout, or abort. One example of how analysis runs could become Inconclusive , is when a metric defines no success or failure conditions. metrics : - name : my-query provider : prometheus : address : http://prometheus.example.com:9090 query : ... Inconclusive analysis runs might also happen when both success and failure conditions are specified, but the measurement value did not meet either condition. metrics : - name : success-rate successCondition : result = 0.90 failureCondition : result 0.50 provider : prometheus : address : http://prometheus.example.com:9090 query : ... A use case for having Inconclusive analysis runs are to enable Argo Rollouts to automate the execution of analysis runs, and collect the measurement, but still allow human judgement to decide whether or not measurement value is acceptable and decide to proceed or abort.","title":"Inconclusive Runs"},{"location":"features/analysis/#delay-analysis-runs","text":"If the analysis run does not need to start immediately (i.e give the metric provider time to collect metrics on the canary version), Analysis Runs can delay the specific metric analysis. Each metric can be configured to have a different delay. In additional to the metric specific delays, the rollouts with background analysis can delay creating an analysis run until a certain step is reached Delaying a specific analysis metric: metrics : - name : success-rate initialDelay : 5m # Do not start this analysis until 5 minutes after the analysis run starts successCondition : result = 0.90 provider : prometheus : address : http://prometheus.example.com:9090 query : ... Delaying starting background analysis run until step 3 (Set Weight 40%): apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : guestbook spec : ... strategy : canary : analysis : templates : - templateName : success-rate startingStep : 2 steps : - setWeight : 20 - pause : { duration : 10m } - setWeight : 40 - pause : { duration : 10m }","title":"Delay Analysis Runs"},{"location":"features/analysis/#experimentation-eg-mann-whitney-analysis","text":"Analysis can also be done as part of an Experiment. This example starts both a canary and baseline ReplicaSet. The ReplicaSets run for 1 hour, then scale down to zero. Call out to Kayenta to perform Mann-Whintney analysis against the two pods. Demonstrates ability to start a short-lived experiment and an asynchronous analysis. This example demonstrates: The ability to start an Experiment as part of rollout steps, which launches multiple ReplicaSets (e.g. baseline canary) The ability to reference and supply pod-template-hash to an AnalysisRun Kayenta metrics Rollout apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : guestbook labels : app : guestbook spec : ... strategy : canary : steps : - experiment : duration : 1h templates : - name : baseline specRef : stable - name : canary specRef : canary analysis : templateName : mann-whitney args : - name : stable-hash valueFrom : podTemplateHashValue : Stable - name : canary-hash valueFrom : podTemplateHashValue : Latest AnalysisTemplate apiVersion : argoproj.io/v1alpha1 kind : AnalysisTemplate metadata : name : mann-whitney spec : args : - name : start-time - name : end-time - name : stable-hash - name : canary-hash metrics : - name : mann-whitney provider : kayenta : address : https://kayenta.example.com application : guestbook canaryConfigName : my-test thresholds : pass : 90 marginal : 75 scopes : - name : default controlScope : scope : app=guestbook and rollouts-pod-template-hash={{args.stable-hash}} step : 60 start : {{args.start-time}} end : {{args.end-time}} experimentScope : scope : app=guestbook and rollouts-pod-template-hash={{args.canary-hash}} step : 60 start : {{args.start-time}} end : {{args.end-time}} Experiment apiVersion : argoproj.io/v1alpha1 kind : Experiment name : name : guestbook-6c54544bf9-0 spec : duration : 1h templates : - name : baseline replicas : 1 spec : containers : - name : guestbook image : guesbook:v1 - name : canary replicas : 1 spec : containers : - name : guestbook image : guesbook:v2 analysis : templateName : mann-whitney args : - name : start-time value : {{experiment.availableAt}} - name : end-time value : {{experiment.finishedAt}} In order to perform multiple kayenta runs over some time duration, the interval and count fields can be supplied. When the start and end fields are omitted from the kayenta scopes, the values will be implicitly decided as: start = if lookback: true start of analysis, otherwise current time - interval end = current time apiVersion : argoproj.io/v1alpha1 kind : AnalysisTemplate metadata : name : mann-whitney spec : args : - name : stable-hash - name : canary-hash metrics : - name : mann-whitney provider : kayenta : address : https://kayenta.intuit.com application : guestbook canaryConfigName : my-test interval : 3600 count : 3 # loopback will cause start time value to be equal to start of analysis # lookback: true thresholds : pass : 90 marginal : 75 scopes : - name : default controlScope : scope : app=guestbook and rollouts-pod-template-hash={{args.stable-hash}} step : 60 experimentScope : scope : app=guestbook and rollouts-pod-template-hash={{args.canary-hash}} step : 60","title":"Experimentation (e.g. Mann-Whitney Analysis)"},{"location":"features/analysis/#run-experiment-indefinitely","text":"Experiments can run for an indefinite duration by omitting the duration field. Indefinite experiments would be stopped externally, or through the completion of a referenced analysis.","title":"Run Experiment Indefinitely"},{"location":"features/analysis/#job-metrics","text":"A Kubernetes Job can be used to run analysis. When a Job is used, the metric is considered successful if the Job completes and had an exit code of zero, otherwise it is failed. metrics : - name : test provider : job : backoffLimit : 1 spec : template : spec : containers : - name : test image : my-image:latest command : [ my-test-script , my-service.default.svc.cluster.local ] restartPolicy : Never","title":"Job Metrics"},{"location":"features/analysis/#wavefront-metrics","text":"A Wavefront query can be used to obtain measurements for analysis. apiVersion : argoproj.io/v1alpha1 kind : AnalysisTemplate metadata : name : success-rate spec : args : - name : service-name metrics : - name : success-rate interval : 5m successCondition : result = 0.95 failureLimit : 3 provider : wavefront : address : example.wavefront.com query : | sum(rate( 5m, ts( istio.requestcount.count , response_code!=500 and destination_service= {{args.service-name}} ))) / sum(rate( 5m, ts( istio.requestcount.count , reporter=client and destination_service= {{args.service-name}} ))) Wavefront api tokens can be configured in a kubernetes secret in argo-rollouts namespace. apiVersion : v1 kind : Secret metadata : name : wavefront-api-tokens type : Opaque data : example1.wavefront.com : token1 example2.wavefront.com : token2","title":"Wavefront Metrics"},{"location":"features/analysis/#web-metrics","text":"A webhook can be used to call out to some external service to obtain the measurement. This example makes a HTTP GET request to some URL. The webhook response must return JSON content. The result of the jsonPath expression will be assigned to the result variable that can be referenced in the successCondition and failureCondition expressions. metrics : - name : webmetric successCondition : result == true provider : web : url : http://my-server.com/api/v1/measurement?service={{ args.service-name }} timeoutSeconds : 20 # defaults to 10 seconds headers : - key : Authorization value : Bearer {{ args.api-token }} jsonPath : {$.results.ok} In this example, the measurement is successful if the json response returns \"true\" for the nested ok field. { results : { ok : true , successPercent : 0.95 } } For success conditions that need to evaluate a numeric return value the asInt or asFloat functions can be used to convert the result value. metrics : - name : webmetric successCondition : asFloat(result) = 0.90 provider : web : url : http://my-server.com/api/v1/measurement?service={{ args.service-name }} headers : - key : Authorization value : Bearer {{ args.api-token }} jsonPath : {$.results.successPercent}","title":"Web Metrics"},{"location":"features/bluegreen/","text":"BlueGreen Deployment Strategy A Blue Green Deployment allows users to reduce the amount of time multiple versions running at the same time. Overview In addition to managing ReplicaSets, the rollout controller will modify a Service resource during the BlueGreenUpdate strategy. The Rollout spec has users specify a reference to active service and optionally a preview service in the same namespace. The active Service is used to send regular application traffic to the old version, while the preview Service is used as funnel traffic to the new version. The rollout controller ensures proper traffic routing by injecting a unique hash of the ReplicaSet to these services' selectors. This allows the rollout to define an active and preview stack and a process to migrate replica sets from the preview to the active. When there is a change to the .spec.template field of a rollout, the controller will create the new ReplicaSet. If the active service is not sending traffic to a ReplicaSet, the controller will immediately start sending traffic to the ReplicaSet. Otherwise, the active service will point at the old ReplicaSet while the ReplicaSet becomes available. Once the new ReplicaSet becomes available, the controller will modify the active service to point at the new ReplicaSet. After waiting some time configured by the .spec.strategy.blueGreen.scaleDownDelaySeconds , the controller will scale down the old ReplicaSet. Important When the rollout changes the selector on a service, there is a propagation delay before all the nodes update their IP tables to send traffic to the new pods instead of the old. During this delay, traffic will be directed to the old pods if the nodes have not been updated yet. In order to prevent the packets from being sent to a node that killed the old pod, the rollout uses the scaleDownDelaySeconds field to give nodes enough time to broadcast the IP table changes. Example apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : rollout-bluegreen spec : replicas : 2 revisionHistoryLimit : 2 selector : matchLabels : app : rollout-bluegreen template : metadata : labels : app : rollout-bluegreen spec : containers : - name : rollouts-demo image : argoproj/rollouts-demo:blue imagePullPolicy : Always ports : - containerPort : 8080 strategy : blueGreen : # activeService specifies the service to update with the new template hash at time of promotion. # This field is mandatory for the blueGreen update strategy. activeService : rollout-bluegreen-active # previewService specifies the service to update with the new template hash before promotion. # This allows the preview stack to be reachable without serving production traffic. # This field is optional. previewService : rollout-bluegreen-preview # autoPromotionEnabled disables automated promotion of the new stack by pausing the rollout # immediately before the promotion. If omitted, the default behavior is to promote the new # stack as soon as the ReplicaSet are completely ready/available. # Rollouts can be resumed using: `kubectl argo rollouts resume ROLLOUT` autoPromotionEnabled : false Configurable Features Here are the optional fields that will change the behavior of BlueGreen deployment: spec : strategy : blueGreen : autoPromotionEnabled : boolean autoPromotionSeconds : *int32 antiAffinity : object previewService : string prePromotionAnalysis : object postPromotionAnalysis : object previewReplicaCount : *int32 scaleDownDelaySeconds : *int32 scaleDownDelayRevisionLimit : *int32 antiAffinityBetweenVersion : bool autoPromotionEnabled The AutoPromotionEnabled will make the rollout automatically promote the new ReplicaSet to the active service once the new ReplicaSet is healthy. This field is defaulted to true if it is not specified. Defaults to true autoPromotionSeconds The AutoPromotionSeconds will make the rollout automatically promote the new ReplicaSet to active Service after the AutoPromotionSeconds time has passed since the rollout has entered a paused state. If the AutoPromotionEnabled field is set to true, this field will be ignored Defaults to nil antiAffinity Check out the Anti Affinity document document for more information. Defaults to nil prePromotionAnalysis Configures the Analysis before it switches traffic to the new version. The AnalysisRun can be used to block the Service selector switch until the AnalysisRun finishes successful. The success or failure of the analysis run decides if the Rollout will switch traffic, or abort the Rollout completely. Defaults to nil postPromotionAnalysis Configures the Analysis after the traffic switch to new version. If the analysis run fails or errors out, the Rollout enters an aborted state and switch traffic back to the previous stable Replicaset. If scaleDownDelaySeconds is specified, the controller will cancel any AnalysisRuns at time of scaleDownDelay to scale down the ReplicaSet. If it is omitted, and post analysis is specified, it will scale down the ReplicaSet only after the AnalysisRun completes (with a minimum of 30 seconds). Defaults to nil previewService The PreviewService field references a Service that will be modified to send traffic to the new replicaset before the new one is promoted to receiving traffic from the active service. Once the new replicaset start receives traffic from the active service, the preview service will be modified to send traffic to no ReplicaSets. The Rollout always makes sure that the preview service is sending traffic to the new ReplicaSet. As a result, if a new version is introduced before the old version is promoted to the active service, the controller will immediately switch over to the new version. This feature is used to provide an endpoint that can be used to test a new version of an application. Defaults to an empty string previewReplicaCount The PreviewReplicaCount will indicate the number of replicas that the new version of an application should run. Once the application is ready to promote to the active service, the controller will scale the new ReplicaSet to the value of the spec.replicas . The rollout will not switch over the active service to the new ReplicaSet until it matches the spec.replicas count. This feature is mainly used to save resources during the testing phase. If the application does not need a fully scaled up application for the tests, this feature can help save some resources. Defaults to nil scaleDownDelaySeconds The ScaleDownDelaySeconds is used to delay scaling down the old ReplicaSet after the active Service is switched to the new ReplicaSet. Defaults to 30 scaleDownDelayRevisionLimit The ScaleDownDelayRevisionLimit limits the number of old active ReplicaSets to keep scaled up while they wait for the scaleDownDelay to pass after being removed from the active service. Defaults to nil","title":"BlueGreen"},{"location":"features/bluegreen/#bluegreen-deployment-strategy","text":"A Blue Green Deployment allows users to reduce the amount of time multiple versions running at the same time.","title":"BlueGreen Deployment Strategy"},{"location":"features/bluegreen/#overview","text":"In addition to managing ReplicaSets, the rollout controller will modify a Service resource during the BlueGreenUpdate strategy. The Rollout spec has users specify a reference to active service and optionally a preview service in the same namespace. The active Service is used to send regular application traffic to the old version, while the preview Service is used as funnel traffic to the new version. The rollout controller ensures proper traffic routing by injecting a unique hash of the ReplicaSet to these services' selectors. This allows the rollout to define an active and preview stack and a process to migrate replica sets from the preview to the active. When there is a change to the .spec.template field of a rollout, the controller will create the new ReplicaSet. If the active service is not sending traffic to a ReplicaSet, the controller will immediately start sending traffic to the ReplicaSet. Otherwise, the active service will point at the old ReplicaSet while the ReplicaSet becomes available. Once the new ReplicaSet becomes available, the controller will modify the active service to point at the new ReplicaSet. After waiting some time configured by the .spec.strategy.blueGreen.scaleDownDelaySeconds , the controller will scale down the old ReplicaSet. Important When the rollout changes the selector on a service, there is a propagation delay before all the nodes update their IP tables to send traffic to the new pods instead of the old. During this delay, traffic will be directed to the old pods if the nodes have not been updated yet. In order to prevent the packets from being sent to a node that killed the old pod, the rollout uses the scaleDownDelaySeconds field to give nodes enough time to broadcast the IP table changes.","title":"Overview"},{"location":"features/bluegreen/#example","text":"apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : rollout-bluegreen spec : replicas : 2 revisionHistoryLimit : 2 selector : matchLabels : app : rollout-bluegreen template : metadata : labels : app : rollout-bluegreen spec : containers : - name : rollouts-demo image : argoproj/rollouts-demo:blue imagePullPolicy : Always ports : - containerPort : 8080 strategy : blueGreen : # activeService specifies the service to update with the new template hash at time of promotion. # This field is mandatory for the blueGreen update strategy. activeService : rollout-bluegreen-active # previewService specifies the service to update with the new template hash before promotion. # This allows the preview stack to be reachable without serving production traffic. # This field is optional. previewService : rollout-bluegreen-preview # autoPromotionEnabled disables automated promotion of the new stack by pausing the rollout # immediately before the promotion. If omitted, the default behavior is to promote the new # stack as soon as the ReplicaSet are completely ready/available. # Rollouts can be resumed using: `kubectl argo rollouts resume ROLLOUT` autoPromotionEnabled : false","title":"Example"},{"location":"features/bluegreen/#configurable-features","text":"Here are the optional fields that will change the behavior of BlueGreen deployment: spec : strategy : blueGreen : autoPromotionEnabled : boolean autoPromotionSeconds : *int32 antiAffinity : object previewService : string prePromotionAnalysis : object postPromotionAnalysis : object previewReplicaCount : *int32 scaleDownDelaySeconds : *int32 scaleDownDelayRevisionLimit : *int32 antiAffinityBetweenVersion : bool","title":"Configurable Features"},{"location":"features/bluegreen/#autopromotionenabled","text":"The AutoPromotionEnabled will make the rollout automatically promote the new ReplicaSet to the active service once the new ReplicaSet is healthy. This field is defaulted to true if it is not specified. Defaults to true","title":"autoPromotionEnabled"},{"location":"features/bluegreen/#autopromotionseconds","text":"The AutoPromotionSeconds will make the rollout automatically promote the new ReplicaSet to active Service after the AutoPromotionSeconds time has passed since the rollout has entered a paused state. If the AutoPromotionEnabled field is set to true, this field will be ignored Defaults to nil","title":"autoPromotionSeconds"},{"location":"features/bluegreen/#antiaffinity","text":"Check out the Anti Affinity document document for more information. Defaults to nil","title":"antiAffinity"},{"location":"features/bluegreen/#prepromotionanalysis","text":"Configures the Analysis before it switches traffic to the new version. The AnalysisRun can be used to block the Service selector switch until the AnalysisRun finishes successful. The success or failure of the analysis run decides if the Rollout will switch traffic, or abort the Rollout completely. Defaults to nil","title":"prePromotionAnalysis"},{"location":"features/bluegreen/#postpromotionanalysis","text":"Configures the Analysis after the traffic switch to new version. If the analysis run fails or errors out, the Rollout enters an aborted state and switch traffic back to the previous stable Replicaset. If scaleDownDelaySeconds is specified, the controller will cancel any AnalysisRuns at time of scaleDownDelay to scale down the ReplicaSet. If it is omitted, and post analysis is specified, it will scale down the ReplicaSet only after the AnalysisRun completes (with a minimum of 30 seconds). Defaults to nil","title":"postPromotionAnalysis"},{"location":"features/bluegreen/#previewservice","text":"The PreviewService field references a Service that will be modified to send traffic to the new replicaset before the new one is promoted to receiving traffic from the active service. Once the new replicaset start receives traffic from the active service, the preview service will be modified to send traffic to no ReplicaSets. The Rollout always makes sure that the preview service is sending traffic to the new ReplicaSet. As a result, if a new version is introduced before the old version is promoted to the active service, the controller will immediately switch over to the new version. This feature is used to provide an endpoint that can be used to test a new version of an application. Defaults to an empty string","title":"previewService"},{"location":"features/bluegreen/#previewreplicacount","text":"The PreviewReplicaCount will indicate the number of replicas that the new version of an application should run. Once the application is ready to promote to the active service, the controller will scale the new ReplicaSet to the value of the spec.replicas . The rollout will not switch over the active service to the new ReplicaSet until it matches the spec.replicas count. This feature is mainly used to save resources during the testing phase. If the application does not need a fully scaled up application for the tests, this feature can help save some resources. Defaults to nil","title":"previewReplicaCount"},{"location":"features/bluegreen/#scaledowndelayseconds","text":"The ScaleDownDelaySeconds is used to delay scaling down the old ReplicaSet after the active Service is switched to the new ReplicaSet. Defaults to 30","title":"scaleDownDelaySeconds"},{"location":"features/bluegreen/#scaledowndelayrevisionlimit","text":"The ScaleDownDelayRevisionLimit limits the number of old active ReplicaSets to keep scaled up while they wait for the scaleDownDelay to pass after being removed from the active service. Defaults to nil","title":"scaleDownDelayRevisionLimit"},{"location":"features/canary/","text":"Canary Deployment Strategy A canary rollout is a deployment strategy where the operator releases a new version of their application to a small percentage of the production traffic. Overview Since there is no agreed upon standard for a canary deployment, the rollouts controller allows users to outline how they want to run their canary deployment. Users can define a list of steps the controller uses to manipulate the ReplicaSets where there is a change to the .spec.template . Each step will be evaluated before the new ReplicaSet is promoted to the stable version, and the old version is completely scaled down. Each step can have one of two fields. The setWeight field dictates the percentage of traffic that should be sent to the canary, and the pause struct instructs the rollout to pause. When the controller reaches a pause step for a rollout, it will set adds a PauseCondition struct to the .status.PauseConditions field. If the duration field within the pause struct is set, the rollout will not progress to the next step until it has waited for the value of the duration field. Otherwise, the rollout will wait indefinitely until that Pause condition is removed. By using the setWeight and the pause fields, a user can declarative describe how they want to progress to the new version. Below is an example of a canary strategy. Important If the canary Rollout does not use traffic management , the Rollout makes a best effort attempt to achieve the percentage listed in the last setWeight step between the new and old version. For example, if a Rollout has 10 Replicas and 10% for the first setWeight step, the controller will scale the new desired ReplicaSet to 1 replicas and the old stable ReplicaSet to 9. In the case where the setWeight is 15%, the Rollout attempts to get there by rounding up the calculation (i.e. the new ReplicaSet has 2 pod since 15% * 10 rounds up to 2 and the old ReplicaSet has 9 pod since 85% * 10 rounds up to 9). If a user wants to have more fine-grained control of the percentages without a large number of Replicas, that user should use the traffic management functionality. Example apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : example-rollout spec : replicas : 10 selector : matchLabels : app : nginx template : metadata : labels : app : nginx spec : containers : - name : nginx image : nginx:1.15.4 ports : - containerPort : 80 minReadySeconds : 30 revisionHistoryLimit : 3 strategy : canary : #Indicates that the rollout should use the Canary strategy maxSurge : 25% maxUnavailable : 0 steps : - setWeight : 10 - pause : duration : 1h # 1 hour - setWeight : 20 - pause : {} # pause indefinitely Pause Duration Pause duration can be specied with an optional time unit suffix. Valid time units are \"s\", \"m\", \"h\". Defaults to \"s\" if not specified. Values less than zero are not allowed. spec : strategy : canary : steps : - pause : { duration : 10 } # 10 seconds - pause : { duration : 10s } # 10 seconds - pause : { duration : 10m } # 10 minutes - pause : { duration : 10h } # 10 hours - pause : { duration : -10 } # invalid spec! - pause : {} # pause indefinitely If no duration specified for a pause step the rollout will be paused indefinitely. To unpause use the argo kubectl plugin promote command. # promote to the next step kubectl argo rollouts promote rollout Mimicking Rolling Update If the steps field is omitted, the canary strategy will mimic the rolling update behavior. Similar to the deployment, the canary strategy has the maxSurge and maxUnavailable fields to configure how the Rollout should progress to the new version. Other Configurable Features Here are the optional fields that will modify the behavior of canary strategy: spec : strategy : canary : analysis : object antiAffinity : object canaryService : string stableService : string maxSurge : stringOrInt maxUnavailable : stringOrInt trafficRouting : object analysis Configure the background Analysis to execute during the rollout. If the analysis is unsuccessful the rollout will be aborted. Defaults to nil antiAffinity Check out the Anti Affinity document document for more information. Defaults to nil canaryService canaryService references a Service that will be modified to send traffic to only the canary ReplicaSet. This allows users to only hit the canary ReplicaSet. Defaults to an empty string stableService stableService the name of a Service which selects pods with stable version and don't select any pods with canary version. This allows users to only hit the stable ReplicaSet. Defaults to an empty string maxSurge maxSurge defines the maximum number of replicas the rollout can create to move to the correct ratio set by the last setWeight. Max Surge can either be an integer or percentage as a string (i.e. \"20%\") Defaults to \"25%\". maxUnavailable The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxSurge is 0. Defaults to 0 trafficRouting The traffic management rules to apply to control the flow of traffic between the active and canary versions. If not set, the default weighted pod replica based routing will be used. Defaults to nil","title":"Canary"},{"location":"features/canary/#canary-deployment-strategy","text":"A canary rollout is a deployment strategy where the operator releases a new version of their application to a small percentage of the production traffic.","title":"Canary Deployment Strategy"},{"location":"features/canary/#overview","text":"Since there is no agreed upon standard for a canary deployment, the rollouts controller allows users to outline how they want to run their canary deployment. Users can define a list of steps the controller uses to manipulate the ReplicaSets where there is a change to the .spec.template . Each step will be evaluated before the new ReplicaSet is promoted to the stable version, and the old version is completely scaled down. Each step can have one of two fields. The setWeight field dictates the percentage of traffic that should be sent to the canary, and the pause struct instructs the rollout to pause. When the controller reaches a pause step for a rollout, it will set adds a PauseCondition struct to the .status.PauseConditions field. If the duration field within the pause struct is set, the rollout will not progress to the next step until it has waited for the value of the duration field. Otherwise, the rollout will wait indefinitely until that Pause condition is removed. By using the setWeight and the pause fields, a user can declarative describe how they want to progress to the new version. Below is an example of a canary strategy. Important If the canary Rollout does not use traffic management , the Rollout makes a best effort attempt to achieve the percentage listed in the last setWeight step between the new and old version. For example, if a Rollout has 10 Replicas and 10% for the first setWeight step, the controller will scale the new desired ReplicaSet to 1 replicas and the old stable ReplicaSet to 9. In the case where the setWeight is 15%, the Rollout attempts to get there by rounding up the calculation (i.e. the new ReplicaSet has 2 pod since 15% * 10 rounds up to 2 and the old ReplicaSet has 9 pod since 85% * 10 rounds up to 9). If a user wants to have more fine-grained control of the percentages without a large number of Replicas, that user should use the traffic management functionality.","title":"Overview"},{"location":"features/canary/#example","text":"apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : example-rollout spec : replicas : 10 selector : matchLabels : app : nginx template : metadata : labels : app : nginx spec : containers : - name : nginx image : nginx:1.15.4 ports : - containerPort : 80 minReadySeconds : 30 revisionHistoryLimit : 3 strategy : canary : #Indicates that the rollout should use the Canary strategy maxSurge : 25% maxUnavailable : 0 steps : - setWeight : 10 - pause : duration : 1h # 1 hour - setWeight : 20 - pause : {} # pause indefinitely","title":"Example"},{"location":"features/canary/#pause-duration","text":"Pause duration can be specied with an optional time unit suffix. Valid time units are \"s\", \"m\", \"h\". Defaults to \"s\" if not specified. Values less than zero are not allowed. spec : strategy : canary : steps : - pause : { duration : 10 } # 10 seconds - pause : { duration : 10s } # 10 seconds - pause : { duration : 10m } # 10 minutes - pause : { duration : 10h } # 10 hours - pause : { duration : -10 } # invalid spec! - pause : {} # pause indefinitely If no duration specified for a pause step the rollout will be paused indefinitely. To unpause use the argo kubectl plugin promote command. # promote to the next step kubectl argo rollouts promote rollout","title":"Pause Duration"},{"location":"features/canary/#mimicking-rolling-update","text":"If the steps field is omitted, the canary strategy will mimic the rolling update behavior. Similar to the deployment, the canary strategy has the maxSurge and maxUnavailable fields to configure how the Rollout should progress to the new version.","title":"Mimicking Rolling Update"},{"location":"features/canary/#other-configurable-features","text":"Here are the optional fields that will modify the behavior of canary strategy: spec : strategy : canary : analysis : object antiAffinity : object canaryService : string stableService : string maxSurge : stringOrInt maxUnavailable : stringOrInt trafficRouting : object","title":"Other Configurable Features"},{"location":"features/canary/#analysis","text":"Configure the background Analysis to execute during the rollout. If the analysis is unsuccessful the rollout will be aborted. Defaults to nil","title":"analysis"},{"location":"features/canary/#antiaffinity","text":"Check out the Anti Affinity document document for more information. Defaults to nil","title":"antiAffinity"},{"location":"features/canary/#canaryservice","text":"canaryService references a Service that will be modified to send traffic to only the canary ReplicaSet. This allows users to only hit the canary ReplicaSet. Defaults to an empty string","title":"canaryService"},{"location":"features/canary/#stableservice","text":"stableService the name of a Service which selects pods with stable version and don't select any pods with canary version. This allows users to only hit the stable ReplicaSet. Defaults to an empty string","title":"stableService"},{"location":"features/canary/#maxsurge","text":"maxSurge defines the maximum number of replicas the rollout can create to move to the correct ratio set by the last setWeight. Max Surge can either be an integer or percentage as a string (i.e. \"20%\") Defaults to \"25%\".","title":"maxSurge"},{"location":"features/canary/#maxunavailable","text":"The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxSurge is 0. Defaults to 0","title":"maxUnavailable"},{"location":"features/canary/#trafficrouting","text":"The traffic management rules to apply to control the flow of traffic between the active and canary versions. If not set, the default weighted pod replica based routing will be used. Defaults to nil","title":"trafficRouting"},{"location":"features/controller-metrics/","text":"Controller Metrics The Argo Rollouts controller publishes the following prometheus metrics about Argo Rollout objects. Name Description rollout_created_time Creation time in unix timestamp for an rollout. rollout_info Information about rollout. rollout_phase Information on the state of the rollout. rollout_reconcile Rollout reconciliation performance. rollout_reconcile_error Error occurring during the rollout. experiment_created_time Creation time in unix timestamp for an experiment. experiment_info Information about Experiment. experiment_phase Information on the state of the experiment. experiment_reconcile Experiments reconciliation performance. experiment_reconcile_error Error occurring during the experiment. analysis_run_created_time Creation time in unix timestamp for an Analysis Run. analysis_run_info Information about analysis run. analysis_run_metric_phase Information on the duration of a specific metric in the Analysis Run. analysis_run_metric_type Information on the type of a specific metric in the Analysis Runs. analysis_run_phase Information on the state of the Analysis Run. analysis_run_reconcile Analysis Run reconciliation performance. analysis_run_reconcile_error Error occurring during the analysis run. The controller also publishes the following Prometheus metrics to describe the controller health. Name Description controller_clientset_k8s_request_total Number of kubernetes requests executed during application reconciliation. workqueue_adds_total Total number of adds handled by workqueue workqueue_depth Current depth of workqueue workqueue_queue_duration_seconds How long in seconds an item stays in workqueue before being requested. workqueue_work_duration_seconds How long in seconds processing an item from workqueue takes. workqueue_unfinished_work_seconds How many seconds of work has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases. workqueue_longest_running_processor_seconds How many seconds has the longest running processor for workqueue been running workqueue_retries_total Total number of retries handled by workqueue In additional, the Argo Rollouts controllers offers metrics on CPU, memory and file descriptor usage as well as the process start time and current Go processes including memory stats.","title":"Controller Metrics"},{"location":"features/controller-metrics/#controller-metrics","text":"The Argo Rollouts controller publishes the following prometheus metrics about Argo Rollout objects. Name Description rollout_created_time Creation time in unix timestamp for an rollout. rollout_info Information about rollout. rollout_phase Information on the state of the rollout. rollout_reconcile Rollout reconciliation performance. rollout_reconcile_error Error occurring during the rollout. experiment_created_time Creation time in unix timestamp for an experiment. experiment_info Information about Experiment. experiment_phase Information on the state of the experiment. experiment_reconcile Experiments reconciliation performance. experiment_reconcile_error Error occurring during the experiment. analysis_run_created_time Creation time in unix timestamp for an Analysis Run. analysis_run_info Information about analysis run. analysis_run_metric_phase Information on the duration of a specific metric in the Analysis Run. analysis_run_metric_type Information on the type of a specific metric in the Analysis Runs. analysis_run_phase Information on the state of the Analysis Run. analysis_run_reconcile Analysis Run reconciliation performance. analysis_run_reconcile_error Error occurring during the analysis run. The controller also publishes the following Prometheus metrics to describe the controller health. Name Description controller_clientset_k8s_request_total Number of kubernetes requests executed during application reconciliation. workqueue_adds_total Total number of adds handled by workqueue workqueue_depth Current depth of workqueue workqueue_queue_duration_seconds How long in seconds an item stays in workqueue before being requested. workqueue_work_duration_seconds How long in seconds processing an item from workqueue takes. workqueue_unfinished_work_seconds How many seconds of work has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases. workqueue_longest_running_processor_seconds How many seconds has the longest running processor for workqueue been running workqueue_retries_total Total number of retries handled by workqueue In additional, the Argo Rollouts controllers offers metrics on CPU, memory and file descriptor usage as well as the process start time and current Go processes including memory stats.","title":"Controller Metrics"},{"location":"features/experiment/","text":"Experiment CRD What is the Experiment CRD? The Experiment CRD allows users to have ephemeral runs of one or more ReplicaSets. In addition to running ephemeral ReplicaSets, the Experiment CRD can launch AnalysisRuns alongside the ReplicaSets. Generally, those AnalysisRun is used to confirm that new ReplicaSets are running as expected. Use cases of the Experiment CRD A user wants to run two versions of an application for a specific duration to enable Kayenta-style analysis of their application. The Experiment CRD creates 2 ReplicaSets (a baseline and a canary) based on the spec.templates field of the Experiment and waits until both are healthy. After the duration passes, the Experiment scales down the ReplicaSets, and the user can start the Kayenta analysis run. A user can use experiments to enable A/B/C testing by launching multiple experiments with a different version of their application for a long duration. Each Experiment has one PodSpec template that defines a specific version a user would want to run. The Experiment allows users to launch multiple experiments at once and keep each Experiment self-contained. Launching a new version of an existing application with different labels to avoid receiving traffic from a Kubernetes service. The user can run tests against the new version before continuing the Rollout. Experiment Spec Below is an example of an experiment that creates two ReplicaSets with 1 replica each and runs them for 60 seconds once they both become available. Also, the controller launches two AnalysisRuns after the ReplicaSets become available. apiVersion : argoproj.io/v1alpha1 kind : Experiment metadata : name : example-experiment spec : duration : 1m # How long to run the Experiment once the ReplicaSets created from the templates are healthy progressDeadlineSeconds : 30 templates : - name : purple # (required) Unique name for the template that gets used as a part of the ReplicaSet name. replicas : 1 selector : # Same selector that has been as in Deployments and Rollouts matchLabels : app : canary-demo color : purple template : metadata : labels : app : canary-demo color : purple spec : # Same Pod Spec that has been as in Deployments and Rollouts containers : - name : rollouts-demo image : argoproj/rollouts-demo:purple imagePullPolicy : Always ports : - name : http containerPort : 8080 protocol : TCP - name : orange replicas : 1 minReadySeconds : 10 selector : # Same selector that has been as in Deployments and Rollouts matchLabels : app : canary-demo color : orange template : metadata : labels : app : canary-demo color : orange spec : # Same Pod Spec that has been as in Deployments and Rollouts containers : - name : rollouts-demo image : argoproj/rollouts-demo:orange imagePullPolicy : Always ports : - name : http containerPort : 8080 protocol : TCP analyses : - name : http-benchmarkple templateName : http-benchmark args : - name : host value : purple - name : orange templateName : http-benchmark args : - name : host value : orange How does it work? The Experiment controller has two primary responsibilities for each Experiment: Creating and scaling ReplicaSets Creating and watching AnalysisRuns The controller creates a ReplicaSet for each template in the Experiment's .spec.templates . Each template needs a unique name as the controller generates the ReplicaSet's names from the combination of the Experiment's name and template's name. Once the controller creates the ReplicaSets, it waits until those new ReplicaSets become available. Once all the ReplicaSets are available, the controller marks the Experiment as running. The Experiment stays in this state for the duration listed in the spec.duration field or indefinitely if omitted. Once the Experiment is running, the controller creates AnalysisRuns for each analysis listed in the Experiment's .spec.analysis field. These AnalysisRun execute in parallel with the running ReplicaSets. The controller generates the AnalysisRun's name by combining the experiment name and the analysis name with a dash. If an AnalysisRun exists with that name, the controller appends a number to the generated name before recreating the AnalysisRun. If there is another collision, the controller increments the number and try again until it creates an AnalysisRun. Once the Experiment finished, the controller scales down the ReplicaSets it created and terminates the AnalysisRuns if they have not finished. An Experiment is considered complete when: More than the spec.Duration amount of time has passed since the ReplicaSets became healthy. One of the ReplicaSets does not become available, and the progress deadline seconds pass. An AnalysisRun created by an Experiment enters a failed or error state. An external process (i.e. user or pipeline) sets the .spec.terminate to true Integration With Rollouts A rollout using the Canary strategy can create an experiment using the experiment step. The experiment step serves a blocking step for the Rollout as the Rollout does not continue until the Experiment succeeds. The Rollout creates an Experiment using the configuration in the experiment step of the Rollout. The controller generates the Experiment's name by combining the Rollout's name, the PodHash of the new ReplicaSet, the current revision of the Rollout, and the current step-index. If the Experiment fails or errors out, the Rollout enters an aborted state. While in the aborted state, the Rollout fully scales up the stable version and resets the current step index back to zero. Here is an example of a rollout with an experiment step: apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : guestbook labels : app : guestbook spec : strategy : canary : steps : - experiment : duration : 1h templates : - name : baseline specRef : stable replicas : 3 # optional defaults to 1 - name : canary specRef : canary analysis : templateName : mann-whitney args : - name : stable-hash valueFrom : podTemplateHash : baseline - name : canary-hash valueFrom : podTemplateHash : canary In the example above, the Experiment has two templates. The baseline template uses the PodSpec from the stable ReplicaSet, and the canary template uses the PodSpec from the canary ReplicaSet. The Experiment also has one analysis with the mann-whitney template. The stable-hash arg grabs the PodHash from the stable ReplicasSet, and the canary-hash arg grabs the PodHash from the canary ReplicasSet.","title":"Experiments"},{"location":"features/experiment/#experiment-crd","text":"","title":"Experiment CRD"},{"location":"features/experiment/#what-is-the-experiment-crd","text":"The Experiment CRD allows users to have ephemeral runs of one or more ReplicaSets. In addition to running ephemeral ReplicaSets, the Experiment CRD can launch AnalysisRuns alongside the ReplicaSets. Generally, those AnalysisRun is used to confirm that new ReplicaSets are running as expected.","title":"What is the Experiment CRD?"},{"location":"features/experiment/#use-cases-of-the-experiment-crd","text":"A user wants to run two versions of an application for a specific duration to enable Kayenta-style analysis of their application. The Experiment CRD creates 2 ReplicaSets (a baseline and a canary) based on the spec.templates field of the Experiment and waits until both are healthy. After the duration passes, the Experiment scales down the ReplicaSets, and the user can start the Kayenta analysis run. A user can use experiments to enable A/B/C testing by launching multiple experiments with a different version of their application for a long duration. Each Experiment has one PodSpec template that defines a specific version a user would want to run. The Experiment allows users to launch multiple experiments at once and keep each Experiment self-contained. Launching a new version of an existing application with different labels to avoid receiving traffic from a Kubernetes service. The user can run tests against the new version before continuing the Rollout.","title":"Use cases of the Experiment CRD"},{"location":"features/experiment/#experiment-spec","text":"Below is an example of an experiment that creates two ReplicaSets with 1 replica each and runs them for 60 seconds once they both become available. Also, the controller launches two AnalysisRuns after the ReplicaSets become available. apiVersion : argoproj.io/v1alpha1 kind : Experiment metadata : name : example-experiment spec : duration : 1m # How long to run the Experiment once the ReplicaSets created from the templates are healthy progressDeadlineSeconds : 30 templates : - name : purple # (required) Unique name for the template that gets used as a part of the ReplicaSet name. replicas : 1 selector : # Same selector that has been as in Deployments and Rollouts matchLabels : app : canary-demo color : purple template : metadata : labels : app : canary-demo color : purple spec : # Same Pod Spec that has been as in Deployments and Rollouts containers : - name : rollouts-demo image : argoproj/rollouts-demo:purple imagePullPolicy : Always ports : - name : http containerPort : 8080 protocol : TCP - name : orange replicas : 1 minReadySeconds : 10 selector : # Same selector that has been as in Deployments and Rollouts matchLabels : app : canary-demo color : orange template : metadata : labels : app : canary-demo color : orange spec : # Same Pod Spec that has been as in Deployments and Rollouts containers : - name : rollouts-demo image : argoproj/rollouts-demo:orange imagePullPolicy : Always ports : - name : http containerPort : 8080 protocol : TCP analyses : - name : http-benchmarkple templateName : http-benchmark args : - name : host value : purple - name : orange templateName : http-benchmark args : - name : host value : orange","title":"Experiment Spec"},{"location":"features/experiment/#how-does-it-work","text":"The Experiment controller has two primary responsibilities for each Experiment: Creating and scaling ReplicaSets Creating and watching AnalysisRuns The controller creates a ReplicaSet for each template in the Experiment's .spec.templates . Each template needs a unique name as the controller generates the ReplicaSet's names from the combination of the Experiment's name and template's name. Once the controller creates the ReplicaSets, it waits until those new ReplicaSets become available. Once all the ReplicaSets are available, the controller marks the Experiment as running. The Experiment stays in this state for the duration listed in the spec.duration field or indefinitely if omitted. Once the Experiment is running, the controller creates AnalysisRuns for each analysis listed in the Experiment's .spec.analysis field. These AnalysisRun execute in parallel with the running ReplicaSets. The controller generates the AnalysisRun's name by combining the experiment name and the analysis name with a dash. If an AnalysisRun exists with that name, the controller appends a number to the generated name before recreating the AnalysisRun. If there is another collision, the controller increments the number and try again until it creates an AnalysisRun. Once the Experiment finished, the controller scales down the ReplicaSets it created and terminates the AnalysisRuns if they have not finished. An Experiment is considered complete when: More than the spec.Duration amount of time has passed since the ReplicaSets became healthy. One of the ReplicaSets does not become available, and the progress deadline seconds pass. An AnalysisRun created by an Experiment enters a failed or error state. An external process (i.e. user or pipeline) sets the .spec.terminate to true","title":"How does it work?"},{"location":"features/experiment/#integration-with-rollouts","text":"A rollout using the Canary strategy can create an experiment using the experiment step. The experiment step serves a blocking step for the Rollout as the Rollout does not continue until the Experiment succeeds. The Rollout creates an Experiment using the configuration in the experiment step of the Rollout. The controller generates the Experiment's name by combining the Rollout's name, the PodHash of the new ReplicaSet, the current revision of the Rollout, and the current step-index. If the Experiment fails or errors out, the Rollout enters an aborted state. While in the aborted state, the Rollout fully scales up the stable version and resets the current step index back to zero. Here is an example of a rollout with an experiment step: apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : guestbook labels : app : guestbook spec : strategy : canary : steps : - experiment : duration : 1h templates : - name : baseline specRef : stable replicas : 3 # optional defaults to 1 - name : canary specRef : canary analysis : templateName : mann-whitney args : - name : stable-hash valueFrom : podTemplateHash : baseline - name : canary-hash valueFrom : podTemplateHash : canary In the example above, the Experiment has two templates. The baseline template uses the PodSpec from the stable ReplicaSet, and the canary template uses the PodSpec from the canary ReplicaSet. The Experiment also has one analysis with the mann-whitney template. The stable-hash arg grabs the PodHash from the stable ReplicasSet, and the canary-hash arg grabs the PodHash from the canary ReplicasSet.","title":"Integration With Rollouts"},{"location":"features/hpa-support/","text":"Horizontal Pod Autoscaling Horizontal Pod Autoscaling (HPA) automatically scales the number of pods in owned by a Kubernetes resource based on observed CPU utilization or user-configured metrics. In order to accomplish this behavior, HPA only supports resources with the scale endpoint enabled with a couple of required fields. The scale endpoint allows the HPA to understand the current state of a resource and modify the resource to scale it appropriately. Argo Rollouts added support for the scale endpoint in the 0.3.0 release. After being modified by the HPA, the Argo Rollouts controller is responsible for reconciling that change in replicas. Since the strategies within a Rollout are very different, the Argo Rollouts controller handles the scale endpoint differently for various strategies. Below is the behavior for the different strategies: Blue Green The HPA will scale rollouts using the BlueGreen strategy using the metrics from the ReplicaSet receiving traffic from the active service. When the HPA changes the replicas count, the Argo Rollouts controller will first scale up the ReplicaSet receiving traffic from the active service before ReplicaSet receiving traffic from the preview service. The controller will scale up the ReplicaSet receiving traffic from the preview service to prepare it for when the rollout switches the preview to active. If there are no ReplicaSets receiving from the active service, the controller will use all the pods that match the base selector to determine scaling events. In that case, the controller will scale up the latest ReplicaSet to the new count and scale down the older ReplicaSets. Canary (ReplicaSet based) The HPA will scale rollouts using the Canary Strategy using the metrics of all the ReplicasSets within the rollout. Since the Argo Rollouts controller does not control the service that sends traffic to those ReplicaSets, it assumes that all the ReplicaSets in the rollout are receiving traffic. Example Below is an example of a Horizontal Pod Autoscaler that scales a rollout based on CPU metrics: apiVersion : autoscaling/v1 kind : HorizontalPodAutoscaler metadata : name : hpa-rollout-example spec : maxReplicas : 6 minReplicas : 2 scaleTargetRef : apiVersion : argoproj.io/v1alpha1 kind : Rollout name : example-rollout targetCPUUtilizationPercentage : 80 Requirements In order for the HPA to manipulate the rollout, the Kubernetes cluster hosting the rollout CRD needs the subresources support for CRDs. This feature was introduced as alpha in Kubernetes version 1.10 and transitioned to beta in Kubernetes version 1.11. If a user wants to use HPA on v1.10, the Kubernetes Cluster operator will need to add a custom feature flag to the API server. After 1.10, the flag is turned on by default. Check out the following link for more information on setting the custom feature flag.","title":"HPA Support"},{"location":"features/hpa-support/#horizontal-pod-autoscaling","text":"Horizontal Pod Autoscaling (HPA) automatically scales the number of pods in owned by a Kubernetes resource based on observed CPU utilization or user-configured metrics. In order to accomplish this behavior, HPA only supports resources with the scale endpoint enabled with a couple of required fields. The scale endpoint allows the HPA to understand the current state of a resource and modify the resource to scale it appropriately. Argo Rollouts added support for the scale endpoint in the 0.3.0 release. After being modified by the HPA, the Argo Rollouts controller is responsible for reconciling that change in replicas. Since the strategies within a Rollout are very different, the Argo Rollouts controller handles the scale endpoint differently for various strategies. Below is the behavior for the different strategies:","title":"Horizontal Pod Autoscaling"},{"location":"features/hpa-support/#blue-green","text":"The HPA will scale rollouts using the BlueGreen strategy using the metrics from the ReplicaSet receiving traffic from the active service. When the HPA changes the replicas count, the Argo Rollouts controller will first scale up the ReplicaSet receiving traffic from the active service before ReplicaSet receiving traffic from the preview service. The controller will scale up the ReplicaSet receiving traffic from the preview service to prepare it for when the rollout switches the preview to active. If there are no ReplicaSets receiving from the active service, the controller will use all the pods that match the base selector to determine scaling events. In that case, the controller will scale up the latest ReplicaSet to the new count and scale down the older ReplicaSets.","title":"Blue Green"},{"location":"features/hpa-support/#canary-replicaset-based","text":"The HPA will scale rollouts using the Canary Strategy using the metrics of all the ReplicasSets within the rollout. Since the Argo Rollouts controller does not control the service that sends traffic to those ReplicaSets, it assumes that all the ReplicaSets in the rollout are receiving traffic.","title":"Canary (ReplicaSet based)"},{"location":"features/hpa-support/#example","text":"Below is an example of a Horizontal Pod Autoscaler that scales a rollout based on CPU metrics: apiVersion : autoscaling/v1 kind : HorizontalPodAutoscaler metadata : name : hpa-rollout-example spec : maxReplicas : 6 minReplicas : 2 scaleTargetRef : apiVersion : argoproj.io/v1alpha1 kind : Rollout name : example-rollout targetCPUUtilizationPercentage : 80","title":"Example"},{"location":"features/hpa-support/#requirements","text":"In order for the HPA to manipulate the rollout, the Kubernetes cluster hosting the rollout CRD needs the subresources support for CRDs. This feature was introduced as alpha in Kubernetes version 1.10 and transitioned to beta in Kubernetes version 1.11. If a user wants to use HPA on v1.10, the Kubernetes Cluster operator will need to add a custom feature flag to the API server. After 1.10, the flag is turned on by default. Check out the following link for more information on setting the custom feature flag.","title":"Requirements"},{"location":"features/kubectl-plugin/","text":"Kubectl Plugin Kubectl plugins are a way to extend the kubectl command to provide additional behavior. Generally, they are used to add new functionality to kubectl and automate scriptable workflows against a cluster. The official documentation on them is here . Argo Rollouts offers a Kubectl plugin to enrich the experience with Rollouts, Experiments, and Analysis from the command line. It offers the ability to visualize the Argo Rollouts resources and run routine operations like promote or retry on those resources from the command. Installation Manual Install Argo Rollouts Kubectl plugin with curl. curl -LO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-darwin-amd64 For Linux dist, replace darwin with linux Make the kubectl-argo-rollouts binary executable. chmod +x ./kubectl-argo-rollouts-darwin-amd64 Move the binary into your PATH. sudo mv ./kubectl-argo-rollouts-darwin-amd64 /usr/local/bin/kubectl-argo-rollouts Test to ensure the version you installed is up-to-date: kubectl argo rollouts version Krew Currently not supported, but there are plans to make the Argo Rollouts kubectl a part of Krew . Please follow this issue for the most up-to-date information. Usage The best way to get information on the available Argo Rollouts kubectl plugin commands is by run kubectl argo rollouts . The plugin lists all the available commands that the tool can execute along with a description of each commend. All the plugin's commands interact with the Kubernetes API server and use KubeConfig credentials for authentication. Since the plugin leverages the KubeConfig of the user running the command, the plugin has the permissions of those configs. Similar to kubectl, the plugin uses many of the same flags as the kubectl. For example, the kubectl argo rollouts get rollout canary-demo -w command starts a watch on the canary-demo rollout object similar to how the kubectl get deployment canary-demo -w command starts a watch on a deployment. Visualizing Rollouts and Experiments In addition to encapsulating many routine commands, the Argo Rollouts kubectl plugin supports visualizing rollouts and experiments with the get command. The get command provides a clean representation of either the rollouts or the experiments running in a cluster. It returns a bunch of metadata on a resource and a tree view of the child resources created by the parent. As an example, here is a rollout retrieved with a get command: Here is a table to explain some of the icons on the tree view: Icon Kind \u27f3 Rollout \u03a3 Experiment \u03b1 AnalysisRun # Revision \u29c9 ReplicaSet \u25a1 Pod \u229e Job If the get command includes the watch flag ( -w or --watch ), the terminal updates as the rollouts or experiment progress highlighting the progress.","title":"Overview"},{"location":"features/kubectl-plugin/#kubectl-plugin","text":"Kubectl plugins are a way to extend the kubectl command to provide additional behavior. Generally, they are used to add new functionality to kubectl and automate scriptable workflows against a cluster. The official documentation on them is here . Argo Rollouts offers a Kubectl plugin to enrich the experience with Rollouts, Experiments, and Analysis from the command line. It offers the ability to visualize the Argo Rollouts resources and run routine operations like promote or retry on those resources from the command.","title":"Kubectl Plugin"},{"location":"features/kubectl-plugin/#installation","text":"","title":"Installation"},{"location":"features/kubectl-plugin/#manual","text":"Install Argo Rollouts Kubectl plugin with curl. curl -LO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-darwin-amd64 For Linux dist, replace darwin with linux Make the kubectl-argo-rollouts binary executable. chmod +x ./kubectl-argo-rollouts-darwin-amd64 Move the binary into your PATH. sudo mv ./kubectl-argo-rollouts-darwin-amd64 /usr/local/bin/kubectl-argo-rollouts Test to ensure the version you installed is up-to-date: kubectl argo rollouts version","title":"Manual"},{"location":"features/kubectl-plugin/#krew","text":"Currently not supported, but there are plans to make the Argo Rollouts kubectl a part of Krew . Please follow this issue for the most up-to-date information.","title":"Krew"},{"location":"features/kubectl-plugin/#usage","text":"The best way to get information on the available Argo Rollouts kubectl plugin commands is by run kubectl argo rollouts . The plugin lists all the available commands that the tool can execute along with a description of each commend. All the plugin's commands interact with the Kubernetes API server and use KubeConfig credentials for authentication. Since the plugin leverages the KubeConfig of the user running the command, the plugin has the permissions of those configs. Similar to kubectl, the plugin uses many of the same flags as the kubectl. For example, the kubectl argo rollouts get rollout canary-demo -w command starts a watch on the canary-demo rollout object similar to how the kubectl get deployment canary-demo -w command starts a watch on a deployment.","title":"Usage"},{"location":"features/kubectl-plugin/#visualizing-rollouts-and-experiments","text":"In addition to encapsulating many routine commands, the Argo Rollouts kubectl plugin supports visualizing rollouts and experiments with the get command. The get command provides a clean representation of either the rollouts or the experiments running in a cluster. It returns a bunch of metadata on a resource and a tree view of the child resources created by the parent. As an example, here is a rollout retrieved with a get command: Here is a table to explain some of the icons on the tree view: Icon Kind \u27f3 Rollout \u03a3 Experiment \u03b1 AnalysisRun # Revision \u29c9 ReplicaSet \u25a1 Pod \u229e Job If the get command includes the watch flag ( -w or --watch ), the terminal updates as the rollouts or experiment progress highlighting the progress.","title":"Visualizing Rollouts and Experiments"},{"location":"features/kustomize/","text":"Kustomize Integration Kustomize can be extended to understand CRD objects through the use of transformer configs . Using transformer configs, kustomize can be \"taught\" about the structure of a Rollout object and leverage kustomize features such as ConfigMap/Secret generators, variable references, and common labels annotations. To use Rollouts with kustomize: Download rollout-transform.yaml into your kustomize directory. Include rollout-transform.yaml in your kustomize configurations section: kind : Kustomization apiVersion : kustomize.config.k8s.io/v1beta1 configurations : - rollout-transform.yaml A example kustomize app demonstrating the ability to use transformers with Rollouts can be seen here .","title":"Kustomize Support"},{"location":"features/kustomize/#kustomize-integration","text":"Kustomize can be extended to understand CRD objects through the use of transformer configs . Using transformer configs, kustomize can be \"taught\" about the structure of a Rollout object and leverage kustomize features such as ConfigMap/Secret generators, variable references, and common labels annotations. To use Rollouts with kustomize: Download rollout-transform.yaml into your kustomize directory. Include rollout-transform.yaml in your kustomize configurations section: kind : Kustomization apiVersion : kustomize.config.k8s.io/v1beta1 configurations : - rollout-transform.yaml A example kustomize app demonstrating the ability to use transformers with Rollouts can be seen here .","title":"Kustomize Integration"},{"location":"features/restart/","text":"Rollout Pod Restarts For various reasons, applications sometimes need a restart. Since the restart is not changing the version, the application should not have to go through the entire BlueGreen or canary deployment process. The Rollout object supports restarting an application by having the controller do a rolling recreate of all the Pods in a Rollout without going through all the regular BlueGreen or Canary deployments. The controller kills one Pod at a time and relies on the ReplicaSet to scale up new Pods until all the Pods are newer than the restarted time. How it works The Rollout object has a field called .spec.restartAt that takes in a RFC 3339 formatted string (ie. 2020-03-30T21:19:35Z). If the current time is past the restartAt time, the controller knows it needs to restart all the Pods in the Rollout. The controller goes through each ReplicaSet to see if all the Pods have a creation timestamp newer than the restartAt time. To prevent too many Pods from restarting at once, the controller limits itself to deleting one Pod at a time and checks that no other Pods in that ReplicaSet have a deletion timestamp and that ReplicaSet is fully available. The controller checks the ReplicaSets in the following order: 1. stable ReplicaSet, 2. new ReplicaSet, and 3rd. all the other ReplicaSets starting with the oldest. Once the controller has confirmed all the Pods are newer than the restartAt time, the controller sets the status.restartedAt field to indicate that the Rollout has been successfully restarted. If a change occurs to the spec.template during a restart, the restart is canceled (by setting the status.restartedAt to the spec.restartAt ) since the Rollout has to bring up a new stack. Note: Unlike deployments, whose restarts are essentially a normal rolling upgrade which happened to be triggered by a timestamp in the pod spec annotation, Rollouts facilitates restarts by sequentially and individually terminating pods one by one. This design choice was made in order to allow a restart to occur even when a Rollout was in the middle of a long-running blue-green/canary update. However, some consequences of this are: Restarting a Rollout with a single replica will cause downtime since the Rollout would only have a single one Pod which would be brought down during the restart. Restarting a rollout occurs slower than a deployment's rolling update, since the sequential restarting of pods is more conservative than the maxSurge, maxUnavailable fields of a rolling update. Kubectl command The Argo Rollouts kubectl plugin has a command for restarting Rollouts. Check it out here . Rescheduled Restarts Users can reschedule a restart on their Rollout by setting the .spec.restartAt field to a time in the future. The controller only starts the restart after the current time is after the restartAt time.","title":"Restarting Rollouts"},{"location":"features/restart/#rollout-pod-restarts","text":"For various reasons, applications sometimes need a restart. Since the restart is not changing the version, the application should not have to go through the entire BlueGreen or canary deployment process. The Rollout object supports restarting an application by having the controller do a rolling recreate of all the Pods in a Rollout without going through all the regular BlueGreen or Canary deployments. The controller kills one Pod at a time and relies on the ReplicaSet to scale up new Pods until all the Pods are newer than the restarted time.","title":"Rollout Pod Restarts"},{"location":"features/restart/#how-it-works","text":"The Rollout object has a field called .spec.restartAt that takes in a RFC 3339 formatted string (ie. 2020-03-30T21:19:35Z). If the current time is past the restartAt time, the controller knows it needs to restart all the Pods in the Rollout. The controller goes through each ReplicaSet to see if all the Pods have a creation timestamp newer than the restartAt time. To prevent too many Pods from restarting at once, the controller limits itself to deleting one Pod at a time and checks that no other Pods in that ReplicaSet have a deletion timestamp and that ReplicaSet is fully available. The controller checks the ReplicaSets in the following order: 1. stable ReplicaSet, 2. new ReplicaSet, and 3rd. all the other ReplicaSets starting with the oldest. Once the controller has confirmed all the Pods are newer than the restartAt time, the controller sets the status.restartedAt field to indicate that the Rollout has been successfully restarted. If a change occurs to the spec.template during a restart, the restart is canceled (by setting the status.restartedAt to the spec.restartAt ) since the Rollout has to bring up a new stack. Note: Unlike deployments, whose restarts are essentially a normal rolling upgrade which happened to be triggered by a timestamp in the pod spec annotation, Rollouts facilitates restarts by sequentially and individually terminating pods one by one. This design choice was made in order to allow a restart to occur even when a Rollout was in the middle of a long-running blue-green/canary update. However, some consequences of this are: Restarting a Rollout with a single replica will cause downtime since the Rollout would only have a single one Pod which would be brought down during the restart. Restarting a rollout occurs slower than a deployment's rolling update, since the sequential restarting of pods is more conservative than the maxSurge, maxUnavailable fields of a rolling update.","title":"How it works"},{"location":"features/restart/#kubectl-command","text":"The Argo Rollouts kubectl plugin has a command for restarting Rollouts. Check it out here .","title":"Kubectl command"},{"location":"features/restart/#rescheduled-restarts","text":"Users can reschedule a restart on their Rollout by setting the .spec.restartAt field to a time in the future. The controller only starts the restart after the current time is after the restartAt time.","title":"Rescheduled Restarts"},{"location":"features/anti-affinity/anti-affinity/","text":"Anti Affinity Depending on a cluster's configuration, a Blue Green Rollout (or a Canary rollout that uses traffic management) can cause newly created pods to restart after deploying a new version. This can be problematic, especially for applications that cannot startup quickly or do not gracefully exit. This behavior occurs because cluster auto-scaler wants to scale down the extra capacity which was created to support a Rollout running in double capacity. When a node is scaled down, the pods it owns are deleted and recreated. This usually happens if a Rollout has its own dedicated instance group since a Rollout has a greater effect on cluster auto-scaling. Therefore, clusters with a large pool of shared nodes experience the behavior less often. For example, here is a Rollout is running with 8 pods spread across 2 nodes. Each node can hold 6 pods: When the spec.template of the Rollout changes, the controller creates a new ReplicaSet with the spec update and the total number of pods doubles. In this case, the number of pods increases to 16. Since each node can only hold 6 pods, the cluster autoscaler must increase the node count to 3 to accommodate all 16 pods. The resulting distribution of pods across nodes is shown here: Once the Rollout finishes progressing, the old version is scaled down. This leaves the cluster with more nodes than necessary, thus wasting resources (as shown below). The cluster auto-scaler terminates the extra node and the pods are rescheduled on the remaining 2 nodes. To reduce the chance of this behavior, a rollout can inject anti-affinity into the ReplicaSet. This prevents new pods from running on nodes which have the previous version's pods. You can learn more about anti-affinity here . Repeating the above example with anti-affinity enabled, here is what happens when the .spec.template of the Rollout changes. Due to anti-affinity, the new pods cannot be scheduled on nodes which run the old ReplicaSet's pods. As a result, the cluster auto-scaler must create 2 nodes to host the new ReplicaSet's pods. In this case, pods won't be started since the scaled-down nodes are guaranteed to not have the new pods. Anti-affinity is enabled by adding the anti-affinity struct to the Blue-Green or Canary strategy. When the anti-affinity struct is set, controller injects a PodAntiAffinity struct into the ReplicaSet's Affinity. This feature will not modify any of the ReplicaSet's pre-existing affinity rules. Users have a choice between these scheduling rules: RequiredDuringSchedulingIgnoredDuringExecution and PreferredDuringSchedulingIgnoredDuringExecution . RequiredDuringSchedulingIgnoredDuringExecution requires a new version's pods to be on a separate node than the previous versions. If this is not possible, the the new version's pods will not be scheduled. strategy : bluegreen : antiAffinity : requiredDuringSchedulingIgnoredDuringExecution : {} Unlike the Required strategy, PreferredDuringSchedulingIgnoredDuringExecution does not force a new version's pods to be on a separate node than the previous versions. The scheduler attempts to place the new version's pods on separate node(s). If that's not possible, the new version's pods will still be scheduled. The Weight is used to create a priority order for preferred anti-affinity rules. strategy : canary : antiAffinity : preferredDuringSchedulingIgnoredDuringExecution : weight : 1 # Between 1 - 100 Important The main downside to this approach is that deployments can take longer because new nodes are more likely to be created in order to schedule pods with respect to anti-affinity rules. This delay most frequently occurs when a rollout has its own dedicated instance group, since new nodes are more likely to be created to honor anti-affinity rules.","title":"Anti Affinity"},{"location":"features/anti-affinity/anti-affinity/#anti-affinity","text":"Depending on a cluster's configuration, a Blue Green Rollout (or a Canary rollout that uses traffic management) can cause newly created pods to restart after deploying a new version. This can be problematic, especially for applications that cannot startup quickly or do not gracefully exit. This behavior occurs because cluster auto-scaler wants to scale down the extra capacity which was created to support a Rollout running in double capacity. When a node is scaled down, the pods it owns are deleted and recreated. This usually happens if a Rollout has its own dedicated instance group since a Rollout has a greater effect on cluster auto-scaling. Therefore, clusters with a large pool of shared nodes experience the behavior less often. For example, here is a Rollout is running with 8 pods spread across 2 nodes. Each node can hold 6 pods: When the spec.template of the Rollout changes, the controller creates a new ReplicaSet with the spec update and the total number of pods doubles. In this case, the number of pods increases to 16. Since each node can only hold 6 pods, the cluster autoscaler must increase the node count to 3 to accommodate all 16 pods. The resulting distribution of pods across nodes is shown here: Once the Rollout finishes progressing, the old version is scaled down. This leaves the cluster with more nodes than necessary, thus wasting resources (as shown below). The cluster auto-scaler terminates the extra node and the pods are rescheduled on the remaining 2 nodes. To reduce the chance of this behavior, a rollout can inject anti-affinity into the ReplicaSet. This prevents new pods from running on nodes which have the previous version's pods. You can learn more about anti-affinity here . Repeating the above example with anti-affinity enabled, here is what happens when the .spec.template of the Rollout changes. Due to anti-affinity, the new pods cannot be scheduled on nodes which run the old ReplicaSet's pods. As a result, the cluster auto-scaler must create 2 nodes to host the new ReplicaSet's pods. In this case, pods won't be started since the scaled-down nodes are guaranteed to not have the new pods. Anti-affinity is enabled by adding the anti-affinity struct to the Blue-Green or Canary strategy. When the anti-affinity struct is set, controller injects a PodAntiAffinity struct into the ReplicaSet's Affinity. This feature will not modify any of the ReplicaSet's pre-existing affinity rules. Users have a choice between these scheduling rules: RequiredDuringSchedulingIgnoredDuringExecution and PreferredDuringSchedulingIgnoredDuringExecution . RequiredDuringSchedulingIgnoredDuringExecution requires a new version's pods to be on a separate node than the previous versions. If this is not possible, the the new version's pods will not be scheduled. strategy : bluegreen : antiAffinity : requiredDuringSchedulingIgnoredDuringExecution : {} Unlike the Required strategy, PreferredDuringSchedulingIgnoredDuringExecution does not force a new version's pods to be on a separate node than the previous versions. The scheduler attempts to place the new version's pods on separate node(s). If that's not possible, the new version's pods will still be scheduled. The Weight is used to create a priority order for preferred anti-affinity rules. strategy : canary : antiAffinity : preferredDuringSchedulingIgnoredDuringExecution : weight : 1 # Between 1 - 100 Important The main downside to this approach is that deployments can take longer because new nodes are more likely to be created in order to schedule pods with respect to anti-affinity rules. This delay most frequently occurs when a rollout has its own dedicated instance group, since new nodes are more likely to be created to honor anti-affinity rules.","title":"Anti Affinity"},{"location":"features/traffic-management/","text":"Traffic management Traffic management is controlling the data plane to have intelligent routing rules for an application. These routing rules can manipulate the flow of traffic to different versions of an application enabling Progressive Delivery. These controls limit the blast radius of a new release by ensuring a small percentage of users receive a new version while it is verified. There are various techniques to achieve traffic management: Raw percentages (i.e., 5% of traffic should go to the new version while the rest goes to the stable version) Header-based routing (i.e., send requests with a specific header to the new version) Mirrored traffic where all the traffic is copied and send to the new version in parallel (but the response is ignored) Traffic Management tools in Kubernetes The core Kubernetes objects do not have fine-grained tools needed to fulfill all the requirements of traffic management. At most, Kubernetes offers na\u00efve load balancing capabilities through the Service object by offering an endpoint that routes traffic to a grouping of pods based on that Service's selector. Functionality like traffic mirroring or routing by headers is not possible with the default core Service object, and the only way to control the percentage of traffic to different versions of an application is by manipulating replica counts of those versions. Service Meshes fill this missing functionality in Kubernetes. They introduce new concepts and functionality to control the data plane through the use of CRDs and other core Kubernetes resources. How does Argo Rollouts enable traffic management? Argo Rollouts enables traffic management by manipulating the Service Mesh resources to match the intent of the Rollout. Argo Rollouts currently supports the following service meshes: Istio Nginx Ingress Controller AWS ALB Ingress Controller File a ticket here if you would like another implementation (or thumbs up it if that issue already exists) Regardless of the Service Mesh used, the Rollout object has to set a canary Service and a stable Service in its spec. Here is an example with those fields set: apiVersion : argoproj.io/v1alpha1 kind : Rollout spec : ... strategy : canary : canaryService : canary-service stableService : stable-service trafficRouting : ... The controller modifies these Services to route traffic to the appropriate canary and stable ReplicaSets as the Rollout progresses. These Services are used by the Service Mesh to define what group of pods should receive the canary and stable traffic. Additionally, the Argo Rollouts controller needs to treat the Rollout object differently when using traffic management. In particular, the Stable ReplicaSet owned by the Rollout remains fully scaled up as the Rollout progresses through the Canary steps. Since the traffic is controlled independently by the Service Mesh resources, the controller needs to make a best effort to ensure that the Stable and New ReplicaSets are not overwhelmed by the traffic sent to them. By leaving the Stable ReplicaSet scaled up, the controller is ensuring that the Stable ReplicaSet can handle 100% of the traffic at any time 1 . The New ReplicaSet follows the same behavior as without traffic management. The new ReplicaSet's replica count is equal to the latest SetWeight step percentage multiple by the total replica count of the Rollout. This calculation ensures that the canary version does not receive more traffic than it can handle. The Rollout has to assume that the application can handle 100% of traffic if it is fully scaled up. It should outsource to the HPA to detect if the Rollout needs to more replicas if 100% isn't enough.","title":"Overview"},{"location":"features/traffic-management/#traffic-management","text":"Traffic management is controlling the data plane to have intelligent routing rules for an application. These routing rules can manipulate the flow of traffic to different versions of an application enabling Progressive Delivery. These controls limit the blast radius of a new release by ensuring a small percentage of users receive a new version while it is verified. There are various techniques to achieve traffic management: Raw percentages (i.e., 5% of traffic should go to the new version while the rest goes to the stable version) Header-based routing (i.e., send requests with a specific header to the new version) Mirrored traffic where all the traffic is copied and send to the new version in parallel (but the response is ignored)","title":"Traffic management"},{"location":"features/traffic-management/#traffic-management-tools-in-kubernetes","text":"The core Kubernetes objects do not have fine-grained tools needed to fulfill all the requirements of traffic management. At most, Kubernetes offers na\u00efve load balancing capabilities through the Service object by offering an endpoint that routes traffic to a grouping of pods based on that Service's selector. Functionality like traffic mirroring or routing by headers is not possible with the default core Service object, and the only way to control the percentage of traffic to different versions of an application is by manipulating replica counts of those versions. Service Meshes fill this missing functionality in Kubernetes. They introduce new concepts and functionality to control the data plane through the use of CRDs and other core Kubernetes resources.","title":"Traffic Management tools in Kubernetes"},{"location":"features/traffic-management/#how-does-argo-rollouts-enable-traffic-management","text":"Argo Rollouts enables traffic management by manipulating the Service Mesh resources to match the intent of the Rollout. Argo Rollouts currently supports the following service meshes: Istio Nginx Ingress Controller AWS ALB Ingress Controller File a ticket here if you would like another implementation (or thumbs up it if that issue already exists) Regardless of the Service Mesh used, the Rollout object has to set a canary Service and a stable Service in its spec. Here is an example with those fields set: apiVersion : argoproj.io/v1alpha1 kind : Rollout spec : ... strategy : canary : canaryService : canary-service stableService : stable-service trafficRouting : ... The controller modifies these Services to route traffic to the appropriate canary and stable ReplicaSets as the Rollout progresses. These Services are used by the Service Mesh to define what group of pods should receive the canary and stable traffic. Additionally, the Argo Rollouts controller needs to treat the Rollout object differently when using traffic management. In particular, the Stable ReplicaSet owned by the Rollout remains fully scaled up as the Rollout progresses through the Canary steps. Since the traffic is controlled independently by the Service Mesh resources, the controller needs to make a best effort to ensure that the Stable and New ReplicaSets are not overwhelmed by the traffic sent to them. By leaving the Stable ReplicaSet scaled up, the controller is ensuring that the Stable ReplicaSet can handle 100% of the traffic at any time 1 . The New ReplicaSet follows the same behavior as without traffic management. The new ReplicaSet's replica count is equal to the latest SetWeight step percentage multiple by the total replica count of the Rollout. This calculation ensures that the canary version does not receive more traffic than it can handle. The Rollout has to assume that the application can handle 100% of traffic if it is fully scaled up. It should outsource to the HPA to detect if the Rollout needs to more replicas if 100% isn't enough.","title":"How does Argo Rollouts enable traffic management?"},{"location":"features/traffic-management/alb/","text":"AWS Application Load Balancer (ALB) The AWS ALB Ingress Controller enables traffic management through an Ingress object that configuring an ALB that routes traffic proportionally to different services. The ALB consists of a listener and rules with actions. Listeners define how traffic from client comes in, and rules define how to handle those requests with various actions. One action allows users to forward traffic to multiple TargetGroups (with each being defined as a Kubernetes service) You can read more about ALB concepts here . An ALB Ingress defines a desired ALB with listener and rules through its annotations and spec. The ALB Ingress controller honors an annotation on an Ingress called alb.ingress.kubernetes.io/actions. service-name that allows users to define the actions of a service listed in the Ingress with a \"use-annotations\" value for the ports. Below is an example of an ingress: apiVersion : extensions/v1beta1 kind : Ingress metadata : annotations : alb.ingress.kubernetes.io/actions.stable-service : | { Type : forward , ForwardConfig :{ TargetGroups :[ { Weight :10, ServiceName : canary-service , ServicePort : 80 }, { Weight :90, ServiceName : stable-service , ServicePort : 80 } ] } } kubernetes.io/ingress.class : alb name : ingress spec : rules : - http : paths : - backend : serviceName : stable-service servicePort : use-annotation path : /* This Ingress uses the alb.ingress.kubernetes.io/actions.stable-service annotation to define how to route traffic to the various services for the rule with the stable-service serviceName instead of sending traffic to the canary-service service. You can read more about these annotations on the official documentation . Integration with Argo Rollouts There are a couple of required fields in a Rollout to send split traffic between versions using ALB ingresses. Below is an example of a Rollout with those fields: apiVersion : argoproj.io/v1alpha1 kind : Rollout spec : ... strategy : canary : canaryService : canary-service # required stableService : stable-service # required trafficRouting : alb : ingress : ingress # required servicePort : 443 # required annotationPrefix : custom.alb.ingress.kubernetes.io # optional The ingress field is a reference to an Ingress in the same namespace of the Rollout, and the servicePort field refers a port of a service. The Rollout requires the Ingress and servicePort to modify the ALB to route traffic to the stable and canary Services. Within the Ingress, looks for the stableService within the Ingress's rules and adds an action annotation for that the action. As the Rollout progresses through the Canary steps, the controller updates the Ingress's action annotation to reflect the desired state of the Rollout enabling traffic splitting between two different versions. Since the ALB Ingress controller allows users to configure the annotation prefix used by the Ingress controller, Rollouts can specify the optional annotationPrefix field. The Ingress uses that prefix instead of the default alb.ingress.kubernetes.io if the field set. The Rollout adds another annotation called rollouts.argoproj.io/managed-alb-actions to the Ingress to help the controller manage the Ingresses. This annotation indicates which actions are being managed by Rollout objects (since multiple Rollouts can reference one Ingress). If a Rollout is deleted, the Argo Rollouts controller uses this annotation to see that this action is no longer managed, and it is reset to only the stable service with 100 weight. Using Argo Rollouts with multiple ALB ingress controllers As a default, the Argo Rollouts controller only operates on ingresses with the kubernetes.io/ingress.class annotation set to alb . A user can configure the controller to operate on Ingresses with different kubernetes.io/ingress.class values by specifying the --alb-ingress-classes flag. A user can list the --alb-ingress-classes flag multiple times if the Argo Rollouts controller should operate on multiple values. This solves the case where a cluster has multiple Ingress controllers operating on different kubernetes.io/ingress.class values. If the user would like the controller to operate on any Ingress without the kubernetes.io/ingress.class annotation, a user should add the following --alb-ingress-classes '' .","title":"AWS ALB"},{"location":"features/traffic-management/alb/#aws-application-load-balancer-alb","text":"The AWS ALB Ingress Controller enables traffic management through an Ingress object that configuring an ALB that routes traffic proportionally to different services. The ALB consists of a listener and rules with actions. Listeners define how traffic from client comes in, and rules define how to handle those requests with various actions. One action allows users to forward traffic to multiple TargetGroups (with each being defined as a Kubernetes service) You can read more about ALB concepts here . An ALB Ingress defines a desired ALB with listener and rules through its annotations and spec. The ALB Ingress controller honors an annotation on an Ingress called alb.ingress.kubernetes.io/actions. service-name that allows users to define the actions of a service listed in the Ingress with a \"use-annotations\" value for the ports. Below is an example of an ingress: apiVersion : extensions/v1beta1 kind : Ingress metadata : annotations : alb.ingress.kubernetes.io/actions.stable-service : | { Type : forward , ForwardConfig :{ TargetGroups :[ { Weight :10, ServiceName : canary-service , ServicePort : 80 }, { Weight :90, ServiceName : stable-service , ServicePort : 80 } ] } } kubernetes.io/ingress.class : alb name : ingress spec : rules : - http : paths : - backend : serviceName : stable-service servicePort : use-annotation path : /* This Ingress uses the alb.ingress.kubernetes.io/actions.stable-service annotation to define how to route traffic to the various services for the rule with the stable-service serviceName instead of sending traffic to the canary-service service. You can read more about these annotations on the official documentation .","title":"AWS Application Load Balancer (ALB)"},{"location":"features/traffic-management/alb/#integration-with-argo-rollouts","text":"There are a couple of required fields in a Rollout to send split traffic between versions using ALB ingresses. Below is an example of a Rollout with those fields: apiVersion : argoproj.io/v1alpha1 kind : Rollout spec : ... strategy : canary : canaryService : canary-service # required stableService : stable-service # required trafficRouting : alb : ingress : ingress # required servicePort : 443 # required annotationPrefix : custom.alb.ingress.kubernetes.io # optional The ingress field is a reference to an Ingress in the same namespace of the Rollout, and the servicePort field refers a port of a service. The Rollout requires the Ingress and servicePort to modify the ALB to route traffic to the stable and canary Services. Within the Ingress, looks for the stableService within the Ingress's rules and adds an action annotation for that the action. As the Rollout progresses through the Canary steps, the controller updates the Ingress's action annotation to reflect the desired state of the Rollout enabling traffic splitting between two different versions. Since the ALB Ingress controller allows users to configure the annotation prefix used by the Ingress controller, Rollouts can specify the optional annotationPrefix field. The Ingress uses that prefix instead of the default alb.ingress.kubernetes.io if the field set. The Rollout adds another annotation called rollouts.argoproj.io/managed-alb-actions to the Ingress to help the controller manage the Ingresses. This annotation indicates which actions are being managed by Rollout objects (since multiple Rollouts can reference one Ingress). If a Rollout is deleted, the Argo Rollouts controller uses this annotation to see that this action is no longer managed, and it is reset to only the stable service with 100 weight.","title":"Integration with Argo Rollouts"},{"location":"features/traffic-management/alb/#using-argo-rollouts-with-multiple-alb-ingress-controllers","text":"As a default, the Argo Rollouts controller only operates on ingresses with the kubernetes.io/ingress.class annotation set to alb . A user can configure the controller to operate on Ingresses with different kubernetes.io/ingress.class values by specifying the --alb-ingress-classes flag. A user can list the --alb-ingress-classes flag multiple times if the Argo Rollouts controller should operate on multiple values. This solves the case where a cluster has multiple Ingress controllers operating on different kubernetes.io/ingress.class values. If the user would like the controller to operate on any Ingress without the kubernetes.io/ingress.class annotation, a user should add the following --alb-ingress-classes '' .","title":"Using Argo Rollouts with multiple ALB ingress controllers"},{"location":"features/traffic-management/istio/","text":"Istio Istio is one of the most popular service mesh in the community and offers a rich feature-set to control the flow of traffic. Istio offers this functionality through a set of CRDs, and the Argo Rollouts controller modifies these resources to manipulate the traffic routing into the desired state. However, the Argo Rollouts controller modifies the Istio resources minimally to gives the developer flexibility while configuring their resources. Istio and Rollouts The Argo Rollout controller achieves traffic shaping by manipulating the Virtual Service. A Virtual Service provides the flexibility to define how to route traffic when a host address is hit. The Argo Rollouts controller manipulates the Virtual Service by using the following Rollout configuration: Canary Service name Stable Service name Virtual Service Name Which HTTP Routes in the Virtual Service Below is an example of a Rollout with all the required fields configured: apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : rollout-example spec : ... strategy : canary : steps : - setWeight : 5 - pause : duration : 10m canaryService : canary-svc # required stableService : stable-svc # required trafficRouting : istio : virtualService : name : rollout-vsvc # required routes : - primary # At least one route is required The controller looks for both the canary and stable service listed as destination hosts within the HTTP routes of the specified Virtual Service and modifies the weights of the destinations as desired. The above Rollout expects that there is a virtual service named rollout-vsvc with an HTTP route named primary . That route should have exactly two destinations: canary-service and stable-svc Services. The canary-svc and stable-svc are required because they indicate to Istio which Pods are the Stable and Canary pods. Here is a Virtual Service that works with the Rollout specified above: apiVersion : networking.istio.io/v1alpha3 kind : VirtualService metadata : name : rollout-vsvc spec : gateways : - istio-rollout-gateway hosts : - istio-rollout.dev.argoproj.io http : - name : primary route : - destination : host : stable-svc weight : 100 - destination : host : canary-svc weight : 0 When the above Rollout progresses through its steps, the controller changes Virtual Service's stable-svc 's weight to 95 and canary-svc 's to 5, wait 5 minutes, and then scales up the canary ReplicaSet to a full replica count. Once it is entirely healthy, the controller changes stable-svc 's selector to point at the canary ReplicaSet and switch the weight back to 100 to stable-svc and 0 to canary-svc . Note The Rollout does not make any other assumptions about the fields within the Virtual Service or the Istio mesh. The user could specify additional configurations for the virtual service like URI rewrite rules on the primary route or any other route if desired. The user can also create specific destination rules for each of the services. Integrating with GitOps The above strategy introduces a problem for users practicing GitOps. The Rollout requires the user-defined Virtual Service to define an HTTP route with both destinations hosts. However, Istio requires routes with multiple destinations to assign a weight to each destination. Since the Argo Rollout controller modifies these Virtual Service's weights as a Rollout progresses through its steps, the Virtual Service becomes out of sync with the Git version. Additionally, if a GitOps tool does an apply after the Argo Rollouts controller changes the Virtual Service's weight, the apply would revert the weight to the percentage stored in the Git repo. At best, the user can specify the desired weight of 100% to the stable service and 0% to the canary service. In this case, the Virtual Service is synced with the Git repo when the Rollout completed all the steps. Argo CD has an open issue here to address this problem. The proposed solution is to introduce an annotation to the VirtualService which tells Argo CD controller to respect the current weights listed and let the Argo Rollouts controller manage them instead. Alternatives Considered Have the Rollout Own the Virtual Service Instead of the controller modifying a reference to a Virtual Service, the Rollout controller would create, manage, and own a Virtual Service. While this approach is GitOps friendly, it introduces other issues: * To provide the same flexibility as referencing Virtual Service within a Rollout, the Rollout needs to inline a large portion of the Istio spec. However, networking is outside the responsibility of the Rollout and makes the Rollout spec necessary complicated. * If Istio introduces a feature, that feature will not be available in Argo Rollouts until implemented within Argo Rollouts. Both of these issues adds more complexity to the users and Argo Rollouts developers compared to referencing a Virtual Service. Implement Istio support through the SMI SMI is the Service Mesh Interface, which serves as a standard interface for all common features of a service mesh. This feature is GitOps friendly, but native Istio has extra functionality that SMI does not currently provide. Granted, Argo Rollouts should integrate with the SMI independent of the native Istio integration.","title":"Istio"},{"location":"features/traffic-management/istio/#istio","text":"Istio is one of the most popular service mesh in the community and offers a rich feature-set to control the flow of traffic. Istio offers this functionality through a set of CRDs, and the Argo Rollouts controller modifies these resources to manipulate the traffic routing into the desired state. However, the Argo Rollouts controller modifies the Istio resources minimally to gives the developer flexibility while configuring their resources.","title":"Istio"},{"location":"features/traffic-management/istio/#istio-and-rollouts","text":"The Argo Rollout controller achieves traffic shaping by manipulating the Virtual Service. A Virtual Service provides the flexibility to define how to route traffic when a host address is hit. The Argo Rollouts controller manipulates the Virtual Service by using the following Rollout configuration: Canary Service name Stable Service name Virtual Service Name Which HTTP Routes in the Virtual Service Below is an example of a Rollout with all the required fields configured: apiVersion : argoproj.io/v1alpha1 kind : Rollout metadata : name : rollout-example spec : ... strategy : canary : steps : - setWeight : 5 - pause : duration : 10m canaryService : canary-svc # required stableService : stable-svc # required trafficRouting : istio : virtualService : name : rollout-vsvc # required routes : - primary # At least one route is required The controller looks for both the canary and stable service listed as destination hosts within the HTTP routes of the specified Virtual Service and modifies the weights of the destinations as desired. The above Rollout expects that there is a virtual service named rollout-vsvc with an HTTP route named primary . That route should have exactly two destinations: canary-service and stable-svc Services. The canary-svc and stable-svc are required because they indicate to Istio which Pods are the Stable and Canary pods. Here is a Virtual Service that works with the Rollout specified above: apiVersion : networking.istio.io/v1alpha3 kind : VirtualService metadata : name : rollout-vsvc spec : gateways : - istio-rollout-gateway hosts : - istio-rollout.dev.argoproj.io http : - name : primary route : - destination : host : stable-svc weight : 100 - destination : host : canary-svc weight : 0 When the above Rollout progresses through its steps, the controller changes Virtual Service's stable-svc 's weight to 95 and canary-svc 's to 5, wait 5 minutes, and then scales up the canary ReplicaSet to a full replica count. Once it is entirely healthy, the controller changes stable-svc 's selector to point at the canary ReplicaSet and switch the weight back to 100 to stable-svc and 0 to canary-svc . Note The Rollout does not make any other assumptions about the fields within the Virtual Service or the Istio mesh. The user could specify additional configurations for the virtual service like URI rewrite rules on the primary route or any other route if desired. The user can also create specific destination rules for each of the services.","title":"Istio and Rollouts"},{"location":"features/traffic-management/istio/#integrating-with-gitops","text":"The above strategy introduces a problem for users practicing GitOps. The Rollout requires the user-defined Virtual Service to define an HTTP route with both destinations hosts. However, Istio requires routes with multiple destinations to assign a weight to each destination. Since the Argo Rollout controller modifies these Virtual Service's weights as a Rollout progresses through its steps, the Virtual Service becomes out of sync with the Git version. Additionally, if a GitOps tool does an apply after the Argo Rollouts controller changes the Virtual Service's weight, the apply would revert the weight to the percentage stored in the Git repo. At best, the user can specify the desired weight of 100% to the stable service and 0% to the canary service. In this case, the Virtual Service is synced with the Git repo when the Rollout completed all the steps. Argo CD has an open issue here to address this problem. The proposed solution is to introduce an annotation to the VirtualService which tells Argo CD controller to respect the current weights listed and let the Argo Rollouts controller manage them instead.","title":"Integrating with GitOps"},{"location":"features/traffic-management/istio/#alternatives-considered","text":"","title":"Alternatives Considered"},{"location":"features/traffic-management/istio/#have-the-rollout-own-the-virtual-service","text":"Instead of the controller modifying a reference to a Virtual Service, the Rollout controller would create, manage, and own a Virtual Service. While this approach is GitOps friendly, it introduces other issues: * To provide the same flexibility as referencing Virtual Service within a Rollout, the Rollout needs to inline a large portion of the Istio spec. However, networking is outside the responsibility of the Rollout and makes the Rollout spec necessary complicated. * If Istio introduces a feature, that feature will not be available in Argo Rollouts until implemented within Argo Rollouts. Both of these issues adds more complexity to the users and Argo Rollouts developers compared to referencing a Virtual Service.","title":"Have the Rollout Own the Virtual Service"},{"location":"features/traffic-management/istio/#implement-istio-support-through-the-smi","text":"SMI is the Service Mesh Interface, which serves as a standard interface for all common features of a service mesh. This feature is GitOps friendly, but native Istio has extra functionality that SMI does not currently provide. Granted, Argo Rollouts should integrate with the SMI independent of the native Istio integration.","title":"Implement Istio support through the SMI"},{"location":"features/traffic-management/nginx/","text":"Nginx The Nginx Ingress Controller enables traffic management through one or more Ingress objects to configure an Nginx deployment that routes traffic directly to pods. Each Nginx Ingress contains multiple annotations that modify the behavior of the Nginx Deployment. For traffic management between different versions of an application, the Nginx Ingress controller provides the capability to split traffic by introducing a second Ingress object (referred to as the canary Ingress) with some special annotations. You can read more about these canary annotations on the official canary annotations documentation page . The canary Ingress ignores any other non-canary nginx annotations. Instead, it leverages the annotation settings from the primary Ingress. The Rollout controller will always set the following two annotations on the canary Ingress (using your configured or the default nginx.ingress.kubernetes.io prefix): canary: true to indicate that this is the canary Ingress canary-weight: num to indicate what percentage of traffic to send to the canary. If all traffic is routed to the stable Service, this is set to 0 You can provide additional annotations to add to the canary Ingress via the additionalIngressAnnotations field to enable features like routing by header or cookie. Integration with Argo Rollouts There are a couple of required fields in a Rollout to send split traffic between versions using Nginx. Below is an example of a Rollout with those fields: apiVersion : argoproj.io/v1alpha1 kind : Rollout spec : ... strategy : canary : canaryService : canary-service # required stableService : stable-service # required trafficRouting : nginx : stableIngress : primary-ingress # required annotationPrefix : customingress.nginx.ingress.kubernetes.io # optional additionalIngressAnnotations : #optional canary-by-header : X-Canary canary-by-header-value : iwantsit The stable Ingress field is a reference to an Ingress in the same namespace of the Rollout. The Rollout requires the primary Ingress routes traffic to the stable Service. The Rollout checks that condition by confirming the Ingress has a backend that matches the Rollout's stableService. The controller routes traffic to the canary Service by creating a second Ingress with the canary annotations. As the Rollout progresses through the Canary steps, the controller updates the canary Ingress's canary annotations to reflect the desired state of the Rollout enabling traffic splitting between two different versions. Since the Nginx Ingress controller allows users to configure the annotation prefix used by the Ingress controller, Rollouts can specify the optional annotationPrefix field. The canary Ingress uses that prefix instead of the default nginx.ingress.kubernetes.io if the field set. Using Argo Rollouts with multiple NGINX ingress controllers As a default, the Argo Rollouts controller only operates on ingresses with the kubernetes.io/ingress.class annotation set to nginx . A user can configure the controller to operate on Ingresses with different kubernetes.io/ingress.class values by specifying the --nginx-ingress-classes flag. A user can list the --nginx-ingress-classes flag multiple times if the Argo Rollouts controller should operate on multiple values. This solves the case where a cluster has multiple Ingress controllers operating on different kubernetes.io/ingress.class values. If the user would like the controller to operate on any Ingress without the kubernetes.io/ingress.class annotation, a user should add the following --nginx-ingress-classes '' .","title":"NGINX"},{"location":"features/traffic-management/nginx/#nginx","text":"The Nginx Ingress Controller enables traffic management through one or more Ingress objects to configure an Nginx deployment that routes traffic directly to pods. Each Nginx Ingress contains multiple annotations that modify the behavior of the Nginx Deployment. For traffic management between different versions of an application, the Nginx Ingress controller provides the capability to split traffic by introducing a second Ingress object (referred to as the canary Ingress) with some special annotations. You can read more about these canary annotations on the official canary annotations documentation page . The canary Ingress ignores any other non-canary nginx annotations. Instead, it leverages the annotation settings from the primary Ingress. The Rollout controller will always set the following two annotations on the canary Ingress (using your configured or the default nginx.ingress.kubernetes.io prefix): canary: true to indicate that this is the canary Ingress canary-weight: num to indicate what percentage of traffic to send to the canary. If all traffic is routed to the stable Service, this is set to 0 You can provide additional annotations to add to the canary Ingress via the additionalIngressAnnotations field to enable features like routing by header or cookie.","title":"Nginx"},{"location":"features/traffic-management/nginx/#integration-with-argo-rollouts","text":"There are a couple of required fields in a Rollout to send split traffic between versions using Nginx. Below is an example of a Rollout with those fields: apiVersion : argoproj.io/v1alpha1 kind : Rollout spec : ... strategy : canary : canaryService : canary-service # required stableService : stable-service # required trafficRouting : nginx : stableIngress : primary-ingress # required annotationPrefix : customingress.nginx.ingress.kubernetes.io # optional additionalIngressAnnotations : #optional canary-by-header : X-Canary canary-by-header-value : iwantsit The stable Ingress field is a reference to an Ingress in the same namespace of the Rollout. The Rollout requires the primary Ingress routes traffic to the stable Service. The Rollout checks that condition by confirming the Ingress has a backend that matches the Rollout's stableService. The controller routes traffic to the canary Service by creating a second Ingress with the canary annotations. As the Rollout progresses through the Canary steps, the controller updates the canary Ingress's canary annotations to reflect the desired state of the Rollout enabling traffic splitting between two different versions. Since the Nginx Ingress controller allows users to configure the annotation prefix used by the Ingress controller, Rollouts can specify the optional annotationPrefix field. The canary Ingress uses that prefix instead of the default nginx.ingress.kubernetes.io if the field set.","title":"Integration with Argo Rollouts"},{"location":"features/traffic-management/nginx/#using-argo-rollouts-with-multiple-nginx-ingress-controllers","text":"As a default, the Argo Rollouts controller only operates on ingresses with the kubernetes.io/ingress.class annotation set to nginx . A user can configure the controller to operate on Ingresses with different kubernetes.io/ingress.class values by specifying the --nginx-ingress-classes flag. A user can list the --nginx-ingress-classes flag multiple times if the Argo Rollouts controller should operate on multiple values. This solves the case where a cluster has multiple Ingress controllers operating on different kubernetes.io/ingress.class values. If the user would like the controller to operate on any Ingress without the kubernetes.io/ingress.class annotation, a user should add the following --nginx-ingress-classes '' .","title":"Using Argo Rollouts with multiple NGINX ingress controllers"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts/","text":"Rollouts Manage argo rollouts Synopsis This command consists of multiple subcommands which can be used to manage Argo Rollouts. kubectl argo rollouts COMMAND [ flags ] Examples # Get guestbook rollout and watch progress kubectl argo rollouts get rollout guestbook -w # Pause the guestbook rollout kubectl argo rollouts pause guestbook # Promote the guestbook rollout kubectl argo rollouts promote guestbook # Abort the guestbook rollout kubectl argo rollouts abort guestbook # Retry the guestbook rollout kubectl argo rollouts retry guestbook Options -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use - h , -- help help for kubectl - argo - rollouts -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use Available Commands rollouts abort - Abort a rollout rollouts create - Create a Rollout, Experiment, AnalysisTemplate, or AnalysisRun resource rollouts get - Get details about rollouts and experiments rollouts list - List rollouts or experiments rollouts pause - Pause a rollout rollouts promote - Promote a rollout rollouts restart - Restart the pods of a rollout rollouts retry - Retry a rollout or experiment rollouts set - Update various values on resources rollouts terminate - Terminate an AalysisRun or Experiment rollouts version - Print version","title":"Rollouts"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts/#rollouts","text":"Manage argo rollouts","title":"Rollouts"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts/#synopsis","text":"This command consists of multiple subcommands which can be used to manage Argo Rollouts. kubectl argo rollouts COMMAND [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts/#examples","text":"# Get guestbook rollout and watch progress kubectl argo rollouts get rollout guestbook -w # Pause the guestbook rollout kubectl argo rollouts pause guestbook # Promote the guestbook rollout kubectl argo rollouts promote guestbook # Abort the guestbook rollout kubectl argo rollouts abort guestbook # Retry the guestbook rollout kubectl argo rollouts retry guestbook","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts/#options","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use - h , -- help help for kubectl - argo - rollouts -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts/#available-commands","text":"rollouts abort - Abort a rollout rollouts create - Create a Rollout, Experiment, AnalysisTemplate, or AnalysisRun resource rollouts get - Get details about rollouts and experiments rollouts list - List rollouts or experiments rollouts pause - Pause a rollout rollouts promote - Promote a rollout rollouts restart - Restart the pods of a rollout rollouts retry - Retry a rollout or experiment rollouts set - Update various values on resources rollouts terminate - Terminate an AalysisRun or Experiment rollouts version - Print version","title":"Available Commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_abort/","text":"Rollouts Abort Abort a rollout Synopsis This command stops progressing the current rollout and reverts all steps. The previous ReplicaSet will be active. Note the 'spec.template' still represents the new rollout version. If the Rollout leaves the aborted state, it will try to go to the new version. Updating the 'spec.template' back to the previous version will fully revert the rollout. kubectl argo rollouts abort ROLLOUT_NAME [ flags ] Examples # Abort a rollout kubectl argo rollouts abort guestbook Options - h , -- help help for abort Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use See Also rollouts - Manage argo rollouts","title":"Rollouts Abort"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_abort/#rollouts-abort","text":"Abort a rollout","title":"Rollouts Abort"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_abort/#synopsis","text":"This command stops progressing the current rollout and reverts all steps. The previous ReplicaSet will be active. Note the 'spec.template' still represents the new rollout version. If the Rollout leaves the aborted state, it will try to go to the new version. Updating the 'spec.template' back to the previous version will fully revert the rollout. kubectl argo rollouts abort ROLLOUT_NAME [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_abort/#examples","text":"# Abort a rollout kubectl argo rollouts abort guestbook","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_abort/#options","text":"- h , -- help help for abort","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_abort/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_abort/#see-also","text":"rollouts - Manage argo rollouts","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create/","text":"Rollouts Create Create a Rollout, Experiment, AnalysisTemplate, or AnalysisRun resource Synopsis This command creates a new Rollout, Experiment, AnalysisTemplate, or AnalysisRun resource from a file. kubectl argo rollouts create [ flags ] Examples # Create an experiement and watch it kubectl argo rollouts create -f my-experiment.yaml -w Options - f , -- filename stringArray Files to use to create the resource - h , -- help help for create -- no - color Do not colorize output - w , -- watch Watch live updates to the resource after creating Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use Available Commands rollouts create analysisrun - Create an AnalysisRun from a template See Also rollouts - Manage argo rollouts","title":"Rollouts Create"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create/#rollouts-create","text":"Create a Rollout, Experiment, AnalysisTemplate, or AnalysisRun resource","title":"Rollouts Create"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create/#synopsis","text":"This command creates a new Rollout, Experiment, AnalysisTemplate, or AnalysisRun resource from a file. kubectl argo rollouts create [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create/#examples","text":"# Create an experiement and watch it kubectl argo rollouts create -f my-experiment.yaml -w","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create/#options","text":"- f , -- filename stringArray Files to use to create the resource - h , -- help help for create -- no - color Do not colorize output - w , -- watch Watch live updates to the resource after creating","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create/#available-commands","text":"rollouts create analysisrun - Create an AnalysisRun from a template","title":"Available Commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create/#see-also","text":"rollouts - Manage argo rollouts","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create_analysisrun/","text":"Rollouts Create Analysisrun Create an AnalysisRun from a template Synopsis This command creates a new AnalysisRun from an existing AnalysisTemplate resources or from an AnalysisTemplate file. kubectl argo rollouts create analysisrun [ flags ] Examples # Create an AnalysisRun from a local template file kubectl argo rollouts create analysisrun --from-file my-analysis-template.yaml # Create an AnalysisRun from a template in the cluster kubectl argo rollouts create analysisrun --from my-analysis-template Options - a , -- argument stringArray Arguments to the parameter template -- from string Create an AnalysisRun from an AnalysisTemplate in the cluster -- from - file string Create an AnalysisRun from an AnalysisTemplate in a local file -- generate - name string Use the specified generateName for the run - h , -- help help for analysisrun -- instance - id string Instance - ID for the AnalysisRun -- name string Use the specified name for the run Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use See Also rollouts create - Create a Rollout, Experiment, AnalysisTemplate, or AnalysisRun resource","title":"Rollouts Create Analysisrun"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create_analysisrun/#rollouts-create-analysisrun","text":"Create an AnalysisRun from a template","title":"Rollouts Create Analysisrun"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create_analysisrun/#synopsis","text":"This command creates a new AnalysisRun from an existing AnalysisTemplate resources or from an AnalysisTemplate file. kubectl argo rollouts create analysisrun [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create_analysisrun/#examples","text":"# Create an AnalysisRun from a local template file kubectl argo rollouts create analysisrun --from-file my-analysis-template.yaml # Create an AnalysisRun from a template in the cluster kubectl argo rollouts create analysisrun --from my-analysis-template","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create_analysisrun/#options","text":"- a , -- argument stringArray Arguments to the parameter template -- from string Create an AnalysisRun from an AnalysisTemplate in the cluster -- from - file string Create an AnalysisRun from an AnalysisTemplate in a local file -- generate - name string Use the specified generateName for the run - h , -- help help for analysisrun -- instance - id string Instance - ID for the AnalysisRun -- name string Use the specified name for the run","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create_analysisrun/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create_analysisrun/#see-also","text":"rollouts create - Create a Rollout, Experiment, AnalysisTemplate, or AnalysisRun resource","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get/","text":"Rollouts Get Get details about rollouts and experiments Synopsis This command consists of multiple subcommands which can be used to get extended information about a rollout or experiment. kubectl argo rollouts get rollout | experiment RESOURCE_NAME [ flags ] Examples # Get a rollout kubectl argo rollouts get rollout guestbook # Watch a rollouts progress kubectl argo rollouts get rollout guestbook -w # Get an experiment kubectl argo rollouts get experiment my-experiment Options - h , -- help help for get Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use Available Commands rollouts get experiment - Get details about an Experiment rollouts get rollout - Get details about a rollout See Also rollouts - Manage argo rollouts","title":"Rollouts Get"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get/#rollouts-get","text":"Get details about rollouts and experiments","title":"Rollouts Get"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get/#synopsis","text":"This command consists of multiple subcommands which can be used to get extended information about a rollout or experiment. kubectl argo rollouts get rollout | experiment RESOURCE_NAME [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get/#examples","text":"# Get a rollout kubectl argo rollouts get rollout guestbook # Watch a rollouts progress kubectl argo rollouts get rollout guestbook -w # Get an experiment kubectl argo rollouts get experiment my-experiment","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get/#options","text":"- h , -- help help for get","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get/#available-commands","text":"rollouts get experiment - Get details about an Experiment rollouts get rollout - Get details about a rollout","title":"Available Commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get/#see-also","text":"rollouts - Manage argo rollouts","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_experiment/","text":"Rollouts Get Experiment Get details about an Experiment Synopsis Get details about and visual representation of a experiment. It returns a bunch of metadata on a resource and a tree view of the child resources created by the parent. Tree view icons Icon Kind \u27f3 Rollout \u03a3 Experiment \u03b1 AnalysisRun # Revision \u29c9 ReplicaSet \u25a1 Pod \u229e Job kubectl argo rollouts get experiment EXPERIMENT_NAME [ flags ] Examples # Get an experiment kubectl argo rollouts get experiment my-experiment # Watch experiment progress kubectl argo rollouts get experiment my-experiment -w Options - h , -- help help for experiment -- no - color Do not colorize output - w , -- watch Watch live updates to the rollout Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use See Also rollouts get - Get details about rollouts and experiments","title":"Rollouts Get Experiment"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_experiment/#rollouts-get-experiment","text":"Get details about an Experiment","title":"Rollouts Get Experiment"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_experiment/#synopsis","text":"Get details about and visual representation of a experiment. It returns a bunch of metadata on a resource and a tree view of the child resources created by the parent. Tree view icons Icon Kind \u27f3 Rollout \u03a3 Experiment \u03b1 AnalysisRun # Revision \u29c9 ReplicaSet \u25a1 Pod \u229e Job kubectl argo rollouts get experiment EXPERIMENT_NAME [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_experiment/#examples","text":"# Get an experiment kubectl argo rollouts get experiment my-experiment # Watch experiment progress kubectl argo rollouts get experiment my-experiment -w","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_experiment/#options","text":"- h , -- help help for experiment -- no - color Do not colorize output - w , -- watch Watch live updates to the rollout","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_experiment/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_experiment/#see-also","text":"rollouts get - Get details about rollouts and experiments","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_rollout/","text":"Rollouts Get Rollout Get details about a rollout Synopsis Get details about and visual representation of a rollout. It returns a bunch of metadata on a resource and a tree view of the child resources created by the parent. Tree view icons Icon Kind \u27f3 Rollout \u03a3 Experiment \u03b1 AnalysisRun # Revision \u29c9 ReplicaSet \u25a1 Pod \u229e Job kubectl argo rollouts get rollout ROLLOUT_NAME [ flags ] Examples # Get a rollout kubectl argo rollouts get rollout guestbook # Watch progress of a rollout kubectl argo rollouts get rollout guestbook -w Options - h , -- help help for rollout -- no - color Do not colorize output - w , -- watch Watch live updates to the rollout Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use See Also rollouts get - Get details about rollouts and experiments","title":"Rollouts Get Rollout"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_rollout/#rollouts-get-rollout","text":"Get details about a rollout","title":"Rollouts Get Rollout"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_rollout/#synopsis","text":"Get details about and visual representation of a rollout. It returns a bunch of metadata on a resource and a tree view of the child resources created by the parent. Tree view icons Icon Kind \u27f3 Rollout \u03a3 Experiment \u03b1 AnalysisRun # Revision \u29c9 ReplicaSet \u25a1 Pod \u229e Job kubectl argo rollouts get rollout ROLLOUT_NAME [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_rollout/#examples","text":"# Get a rollout kubectl argo rollouts get rollout guestbook # Watch progress of a rollout kubectl argo rollouts get rollout guestbook -w","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_rollout/#options","text":"- h , -- help help for rollout -- no - color Do not colorize output - w , -- watch Watch live updates to the rollout","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_rollout/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_rollout/#see-also","text":"rollouts get - Get details about rollouts and experiments","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list/","text":"Rollouts List List rollouts or experiments Synopsis This command consists of multiple subcommands which can be used to lists all of the rollouts or experiments for a specified namespace (uses current namespace context if namespace not specified). kubectl argo rollouts list rollout | experiment [ flags ] Examples # List rollouts kubectl argo rollouts list rollouts # List experiments kubectl argo rollouts list experiments Options - h , -- help help for list Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use Available Commands rollouts list experiments - List experiments rollouts list rollouts - List rollouts See Also rollouts - Manage argo rollouts","title":"Rollouts List"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list/#rollouts-list","text":"List rollouts or experiments","title":"Rollouts List"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list/#synopsis","text":"This command consists of multiple subcommands which can be used to lists all of the rollouts or experiments for a specified namespace (uses current namespace context if namespace not specified). kubectl argo rollouts list rollout | experiment [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list/#examples","text":"# List rollouts kubectl argo rollouts list rollouts # List experiments kubectl argo rollouts list experiments","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list/#options","text":"- h , -- help help for list","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list/#available-commands","text":"rollouts list experiments - List experiments rollouts list rollouts - List rollouts","title":"Available Commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list/#see-also","text":"rollouts - Manage argo rollouts","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_experiments/","text":"Rollouts List Experiments List experiments Synopsis This command lists all of the experiments for a specified namespace (uses current namespace context if namespace not specified). kubectl argo rollouts list experiments [ flags ] Examples # List rollouts kubectl argo rollouts list experiments # List rollouts from all namespaces kubectl argo rollouts list experiments --all-namespaces # List rollouts and watch for changes kubectl argo rollouts list experiments --watch Options -- all - namespaces Include all namespaces - h , -- help help for experiments Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use See Also rollouts list - List rollouts or experiments","title":"Rollouts List Experiments"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_experiments/#rollouts-list-experiments","text":"List experiments","title":"Rollouts List Experiments"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_experiments/#synopsis","text":"This command lists all of the experiments for a specified namespace (uses current namespace context if namespace not specified). kubectl argo rollouts list experiments [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_experiments/#examples","text":"# List rollouts kubectl argo rollouts list experiments # List rollouts from all namespaces kubectl argo rollouts list experiments --all-namespaces # List rollouts and watch for changes kubectl argo rollouts list experiments --watch","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_experiments/#options","text":"-- all - namespaces Include all namespaces - h , -- help help for experiments","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_experiments/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_experiments/#see-also","text":"rollouts list - List rollouts or experiments","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_rollouts/","text":"Rollouts List Rollouts List rollouts Synopsis This command lists all of the rollouts for a specified namespace (uses current namespace context if namespace not specified). kubectl argo rollouts list rollouts [ flags ] Examples # List rollouts kubectl argo rollouts list rollouts # List rollouts from all namespaces kubectl argo rollouts list rollouts --all-namespaces # List rollouts and watch for changes kubectl argo rollouts list rollouts --watch Options -- all - namespaces Include all namespaces - h , -- help help for rollouts -- name string Only show rollout with specified name -- timestamps Print timestamps on updates - w , -- watch Watch for changes Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use See Also rollouts list - List rollouts or experiments","title":"Rollouts List Rollouts"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_rollouts/#rollouts-list-rollouts","text":"List rollouts","title":"Rollouts List Rollouts"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_rollouts/#synopsis","text":"This command lists all of the rollouts for a specified namespace (uses current namespace context if namespace not specified). kubectl argo rollouts list rollouts [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_rollouts/#examples","text":"# List rollouts kubectl argo rollouts list rollouts # List rollouts from all namespaces kubectl argo rollouts list rollouts --all-namespaces # List rollouts and watch for changes kubectl argo rollouts list rollouts --watch","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_rollouts/#options","text":"-- all - namespaces Include all namespaces - h , -- help help for rollouts -- name string Only show rollout with specified name -- timestamps Print timestamps on updates - w , -- watch Watch for changes","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_rollouts/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_rollouts/#see-also","text":"rollouts list - List rollouts or experiments","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_pause/","text":"Rollouts Pause Pause a rollout Synopsis Set the rollout paused state to 'true' kubectl argo rollouts pause ROLLOUT_NAME [ flags ] Examples # Pause a rollout kubectl argo rollouts pause guestbook Options - h , -- help help for pause Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use See Also rollouts - Manage argo rollouts","title":"Rollouts Pause"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_pause/#rollouts-pause","text":"Pause a rollout","title":"Rollouts Pause"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_pause/#synopsis","text":"Set the rollout paused state to 'true' kubectl argo rollouts pause ROLLOUT_NAME [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_pause/#examples","text":"# Pause a rollout kubectl argo rollouts pause guestbook","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_pause/#options","text":"- h , -- help help for pause","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_pause/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_pause/#see-also","text":"rollouts - Manage argo rollouts","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_promote/","text":"Rollouts Promote Promote a rollout Synopsis Unpause a Canary or BlueGreen rollout or skip Canary rollout steps. If a Canary rollout has more steps the rollout will proceed to the next step in the rollout. Use '--skip-all-steps' to skip and remaining steps. If not on a pause step use '--skip-current-step' to progress to the next step in the rollout. kubectl argo rollouts promote ROLLOUT_NAME [ flags ] Examples # Promote a paused rollout kubectl argo rollouts promote guestbook # Promote a canary rollout and skip all remaining stpes kubectl argo rollouts promote guestbook --skip-all-steps Options - h , -- help help for promote - a , -- skip - all - steps Skip remaining steps - c , -- skip - current - step Skip current step Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use See Also rollouts - Manage argo rollouts","title":"Rollouts Promote"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_promote/#rollouts-promote","text":"Promote a rollout","title":"Rollouts Promote"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_promote/#synopsis","text":"Unpause a Canary or BlueGreen rollout or skip Canary rollout steps. If a Canary rollout has more steps the rollout will proceed to the next step in the rollout. Use '--skip-all-steps' to skip and remaining steps. If not on a pause step use '--skip-current-step' to progress to the next step in the rollout. kubectl argo rollouts promote ROLLOUT_NAME [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_promote/#examples","text":"# Promote a paused rollout kubectl argo rollouts promote guestbook # Promote a canary rollout and skip all remaining stpes kubectl argo rollouts promote guestbook --skip-all-steps","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_promote/#options","text":"- h , -- help help for promote - a , -- skip - all - steps Skip remaining steps - c , -- skip - current - step Skip current step","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_promote/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_promote/#see-also","text":"rollouts - Manage argo rollouts","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_restart/","text":"Rollouts Restart Restart the pods of a rollout Synopsis Restart the pods of a rollout kubectl argo rollouts restart ROLLOUT [ flags ] Examples # Restart the pods of a rollout in now kubectl argo rollouts restart ROLLOUT_NAME # Restart the pods of a rollout in ten seconds kubectl argo rollouts restart ROLLOUT_NAME --in 10s Options - h , -- help help for restart - i , -- in string Amount of time before a restart . ( e . g . 30 s , 5 m , 1 h ) Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use See Also rollouts - Manage argo rollouts","title":"Rollouts Restart"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_restart/#rollouts-restart","text":"Restart the pods of a rollout","title":"Rollouts Restart"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_restart/#synopsis","text":"Restart the pods of a rollout kubectl argo rollouts restart ROLLOUT [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_restart/#examples","text":"# Restart the pods of a rollout in now kubectl argo rollouts restart ROLLOUT_NAME # Restart the pods of a rollout in ten seconds kubectl argo rollouts restart ROLLOUT_NAME --in 10s","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_restart/#options","text":"- h , -- help help for restart - i , -- in string Amount of time before a restart . ( e . g . 30 s , 5 m , 1 h )","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_restart/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_restart/#see-also","text":"rollouts - Manage argo rollouts","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry/","text":"Rollouts Retry Retry a rollout or experiment Synopsis This command consists of multiple subcommands which can be used to restart an aborted rollout or a failed experiement. kubectl argo rollouts retry rollout | experiment RESOURCE_NAME [ flags ] Examples # Retry an aborted rollout kubectl argo rollouts retry rollout guestbook # Retry a failed experiment kubectl argo rollouts retry experiment my-experiment Options - h , -- help help for retry Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use Available Commands rollouts retry experiment - Retry an experiment rollouts retry rollout - Retry an aborted rollout See Also rollouts - Manage argo rollouts","title":"Rollouts Retry"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry/#rollouts-retry","text":"Retry a rollout or experiment","title":"Rollouts Retry"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry/#synopsis","text":"This command consists of multiple subcommands which can be used to restart an aborted rollout or a failed experiement. kubectl argo rollouts retry rollout | experiment RESOURCE_NAME [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry/#examples","text":"# Retry an aborted rollout kubectl argo rollouts retry rollout guestbook # Retry a failed experiment kubectl argo rollouts retry experiment my-experiment","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry/#options","text":"- h , -- help help for retry","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry/#available-commands","text":"rollouts retry experiment - Retry an experiment rollouts retry rollout - Retry an aborted rollout","title":"Available Commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry/#see-also","text":"rollouts - Manage argo rollouts","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_experiment/","text":"Rollouts Retry Experiment Retry an experiment Synopsis Retry a failed experiment. kubectl argo rollouts retry experiment EXPERIMENT_NAME [ flags ] Examples # Retry an experiment kubectl argo rollouts retry experiment my-experiment Options - h , -- help help for experiment Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use See Also rollouts retry - Retry a rollout or experiment","title":"Rollouts Retry Experiment"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_experiment/#rollouts-retry-experiment","text":"Retry an experiment","title":"Rollouts Retry Experiment"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_experiment/#synopsis","text":"Retry a failed experiment. kubectl argo rollouts retry experiment EXPERIMENT_NAME [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_experiment/#examples","text":"# Retry an experiment kubectl argo rollouts retry experiment my-experiment","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_experiment/#options","text":"- h , -- help help for experiment","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_experiment/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_experiment/#see-also","text":"rollouts retry - Retry a rollout or experiment","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_rollout/","text":"Rollouts Retry Rollout Retry an aborted rollout Synopsis Retry an aborted rollout kubectl argo rollouts retry rollout ROLLOUT_NAME [ flags ] Examples # Retry an aborted rollout kubectl argo rollouts retry rollout guestbook Options - h , -- help help for rollout Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use See Also rollouts retry - Retry a rollout or experiment","title":"Rollouts Retry Rollout"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_rollout/#rollouts-retry-rollout","text":"Retry an aborted rollout","title":"Rollouts Retry Rollout"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_rollout/#synopsis","text":"Retry an aborted rollout kubectl argo rollouts retry rollout ROLLOUT_NAME [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_rollout/#examples","text":"# Retry an aborted rollout kubectl argo rollouts retry rollout guestbook","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_rollout/#options","text":"- h , -- help help for rollout","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_rollout/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_rollout/#see-also","text":"rollouts retry - Retry a rollout or experiment","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set/","text":"Rollouts Set Update various values on resources Synopsis This command consists of multiple subcommands which can be used to update rollout resources. kubectl argo rollouts set COMMAND [ flags ] Examples # Set rollout image kubectl argo rollouts set image my-rollout argoproj/rollouts-demo:yellow Options - h , -- help help for set Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use Available Commands rollouts set image - Update the image of a rollout See Also rollouts - Manage argo rollouts","title":"Rollouts Set"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set/#rollouts-set","text":"Update various values on resources","title":"Rollouts Set"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set/#synopsis","text":"This command consists of multiple subcommands which can be used to update rollout resources. kubectl argo rollouts set COMMAND [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set/#examples","text":"# Set rollout image kubectl argo rollouts set image my-rollout argoproj/rollouts-demo:yellow","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set/#options","text":"- h , -- help help for set","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set/#available-commands","text":"rollouts set image - Update the image of a rollout","title":"Available Commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set/#see-also","text":"rollouts - Manage argo rollouts","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set_image/","text":"Rollouts Set Image Update the image of a rollout Synopsis Update the image of a rollout kubectl argo rollouts set image ROLLOUT_NAME CONTAINER = IMAGE [ flags ] Examples # Set rollout image kubectl argo rollouts set image my-rollout www = image:v2 Options - h , -- help help for image Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use See Also rollouts set - Update various values on resources","title":"Rollouts Set Image"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set_image/#rollouts-set-image","text":"Update the image of a rollout","title":"Rollouts Set Image"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set_image/#synopsis","text":"Update the image of a rollout kubectl argo rollouts set image ROLLOUT_NAME CONTAINER = IMAGE [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set_image/#examples","text":"# Set rollout image kubectl argo rollouts set image my-rollout www = image:v2","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set_image/#options","text":"- h , -- help help for image","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set_image/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set_image/#see-also","text":"rollouts set - Update various values on resources","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate/","text":"Rollouts Terminate Terminate an AalysisRun or Experiment Synopsis This command consists of multiple subcommands which can be used to terminate an AnalysisRun or Experiment that is in progress. kubectl argo rollouts terminate analysisrun | experiment RESOURCE_NAME [ flags ] Examples # Terminate an analysisRun kubectl argo rollouts terminate analysisrun guestbook-877894d5b-4-success-rate.1 # Terminate a failed experiment kubectl argo rollouts terminate experiment my-experiment Options - h , -- help help for terminate Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use Available Commands rollouts terminate analysisrun - Terminate an AnalysisRun rollouts terminate experiment - Terminate an experiment See Also rollouts - Manage argo rollouts","title":"Rollouts Terminate"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate/#rollouts-terminate","text":"Terminate an AalysisRun or Experiment","title":"Rollouts Terminate"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate/#synopsis","text":"This command consists of multiple subcommands which can be used to terminate an AnalysisRun or Experiment that is in progress. kubectl argo rollouts terminate analysisrun | experiment RESOURCE_NAME [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate/#examples","text":"# Terminate an analysisRun kubectl argo rollouts terminate analysisrun guestbook-877894d5b-4-success-rate.1 # Terminate a failed experiment kubectl argo rollouts terminate experiment my-experiment","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate/#options","text":"- h , -- help help for terminate","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate/#available-commands","text":"rollouts terminate analysisrun - Terminate an AnalysisRun rollouts terminate experiment - Terminate an experiment","title":"Available Commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate/#see-also","text":"rollouts - Manage argo rollouts","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_analysisrun/","text":"Rollouts Terminate Analysisrun Terminate an AnalysisRun Synopsis This command terminates an AnalysisRun. kubectl argo rollouts terminate analysisrun ANALYSISRUN_NAME [ flags ] Examples # Terminate an AnalysisRun kubectl argo rollouts terminate analysis guestbook-877894d5b-4-success-rate.1 Options - h , -- help help for analysisrun Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use See Also rollouts terminate - Terminate an AalysisRun or Experiment","title":"Rollouts Terminate Analysisrun"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_analysisrun/#rollouts-terminate-analysisrun","text":"Terminate an AnalysisRun","title":"Rollouts Terminate Analysisrun"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_analysisrun/#synopsis","text":"This command terminates an AnalysisRun. kubectl argo rollouts terminate analysisrun ANALYSISRUN_NAME [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_analysisrun/#examples","text":"# Terminate an AnalysisRun kubectl argo rollouts terminate analysis guestbook-877894d5b-4-success-rate.1","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_analysisrun/#options","text":"- h , -- help help for analysisrun","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_analysisrun/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_analysisrun/#see-also","text":"rollouts terminate - Terminate an AalysisRun or Experiment","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_experiment/","text":"Rollouts Terminate Experiment Terminate an experiment Synopsis This command terminates an Experiment. kubectl argo rollouts terminate experiment EXPERIMENT_NAME [ flags ] Examples # Terminate an experiment kubectl argo rollouts terminate experiment my-experiment Options - h , -- help help for experiment Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use See Also rollouts terminate - Terminate an AalysisRun or Experiment","title":"Rollouts Terminate Experiment"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_experiment/#rollouts-terminate-experiment","text":"Terminate an experiment","title":"Rollouts Terminate Experiment"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_experiment/#synopsis","text":"This command terminates an Experiment. kubectl argo rollouts terminate experiment EXPERIMENT_NAME [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_experiment/#examples","text":"# Terminate an experiment kubectl argo rollouts terminate experiment my-experiment","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_experiment/#options","text":"- h , -- help help for experiment","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_experiment/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_experiment/#see-also","text":"rollouts terminate - Terminate an AalysisRun or Experiment","title":"See Also"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_version/","text":"Rollouts Version Print version Synopsis Show the version and build information of the Argo Rollouts plugin. kubectl argo rollouts version [ flags ] Examples # Get full version info kubectl argo rollouts version # Get just plugin version number kubectl argo rollouts version --short Options - h , -- help help for version -- short print just the version number Options inherited from parent commands -- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use See Also rollouts - Manage argo rollouts","title":"Rollouts Version"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_version/#rollouts-version","text":"Print version","title":"Rollouts Version"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_version/#synopsis","text":"Show the version and build information of the Argo Rollouts plugin. kubectl argo rollouts version [ flags ]","title":"Synopsis"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_version/#examples","text":"# Get full version info kubectl argo rollouts version # Get just plugin version number kubectl argo rollouts version --short","title":"Examples"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_version/#options","text":"- h , -- help help for version -- short print just the version number","title":"Options"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_version/#options-inherited-from-parent-commands","text":"-- as string Username to impersonate for the operation -- as - group stringArray Group to impersonate for the operation , this flag can be repeated to specify multiple groups . -- cache - dir string Default HTTP cache directory ( default /Users/dthomson/.kube/http-cache ) -- certificate - authority string Path to a cert file for the certificate authority -- client - certificate string Path to a client certificate file for TLS -- client - key string Path to a client key file for TLS -- cluster string The name of the kubeconfig cluster to use -- context string The name of the kubeconfig context to use -- insecure - skip - tls - verify If true , the server s certificate will not be checked for validity. This will make your HTTPS connections insecure - v , -- kloglevel int Log level for kubernetes client library -- kubeconfig string Path to the kubeconfig file to use for CLI requests . -- loglevel string Log level for kubectl argo rollouts ( default info ) - n , -- namespace string If present , the namespace scope for this CLI request -- request - timeout string The length of time to wait before giving up on a single server request . Non - zero values should contain a corresponding time unit ( e . g . 1 s , 2 m , 3 h ) . A value of zero means don t timeout requests. (default 0 ) - s , -- server string The address and port of the Kubernetes API server -- token string Bearer token for authentication to the API server -- user string The name of the kubeconfig user to use","title":"Options inherited from parent commands"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_version/#see-also","text":"rollouts - Manage argo rollouts","title":"See Also"}]}